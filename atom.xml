<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Heitu的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liutaiyu.cn/"/>
  <updated>2019-04-10T14:33:26.817Z</updated>
  <id>http://liutaiyu.cn/</id>
  
  <author>
    <name>Heitu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>华为实习生春招笔试</title>
    <link href="http://liutaiyu.cn/2019/04/10/%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E7%94%9F%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95/"/>
    <id>http://liutaiyu.cn/2019/04/10/华为实习生春招笔试/</id>
    <published>2019-04-10T13:59:50.000Z</published>
    <updated>2019-04-10T14:33:26.817Z</updated>
    
    <content type="html"><![CDATA[<p>机试一共三道题：该题为其中第二道</p><p>题目描述：</p><blockquote><p>给定一个字符串，字符串包含数字、大小写字母以及括号（包括大括号、中括号和小括号），括号可以嵌套。默认括号是匹配的，数字后面一定有括号。按照以下规则展开字符串：</p><ol><li>数字表示括号里的字符串重复的次数，展开后的字符串不包括括号。</li><li>将字符串逆序展开</li></ol></blockquote><p>输入描述：</p><blockquote><p>输入一个长度小于100的字符串</p></blockquote><p>输出描述：</p><blockquote><p>输出展开后的字符串</p></blockquote><p>示例：</p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abc3(A)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAAcba</span><br></pre></td></tr></table></figure><p>思路：该题可以联想到数学式的混合运算的实现，借助栈来判断是否对当前数进行运算。本题中则是借助栈来判断是否对子结构进行一次字符串展开，子结构为: num（string）;算法思路如下：</p><ol><li>从左至右遍历字符串，如果没有遇到右括号，则入栈。</li><li>当遇到右括号时，将其与左括号之间的字符出栈并存入临时字符串，并且重复n次</li><li>将展开后的字符串入栈，重复1，直至遍历结束。</li><li>将栈中的字符串弹出，即为展开后的逆序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String input = sc.nextLine();</span><br><span class="line"></span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(input==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; input.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(input.charAt(i) == <span class="string">']'</span> </span><br><span class="line">               || input.charAt(i) == <span class="string">')'</span> </span><br><span class="line">               || input.charAt(i) == <span class="string">'&#125;'</span>)&#123;</span><br><span class="line">                String t = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">while</span> (!stack.peek().equals(<span class="string">"("</span>)</span><br><span class="line">                       &amp;&amp;!stack.peek().equals(<span class="string">"["</span>)</span><br><span class="line">                       &amp;&amp;!stack.peek().equals(<span class="string">"&#123;"</span>)) &#123;</span><br><span class="line">                    t = t + stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">int</span> s = Integer.valueOf(stack.pop());</span><br><span class="line">                String tmp =<span class="string">""</span>;</span><br><span class="line">                <span class="keyword">while</span> (s--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    tmp +=t;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(tmp);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(String.valueOf(input.charAt(i++)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            res = res + stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;机试一共三道题：该题为其中第二道&lt;/p&gt;
&lt;p&gt;题目描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个字符串，字符串包含数字、大小写字母以及括号（包括大括号、中括号和小括号），括号可以嵌套。默认括号是匹配的，数字后面一定有括号。按照以下规则展开字符串：&lt;/p&gt;
&lt;ol
      
    
    </summary>
    
      <category term="学习" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="算法" scheme="http://liutaiyu.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>博客相关问题</title>
    <link href="http://liutaiyu.cn/2019/04/10/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://liutaiyu.cn/2019/04/10/博客相关问题/</id>
    <published>2019-04-10T07:52:36.000Z</published>
    <updated>2019-04-10T07:58:20.242Z</updated>
    
    <content type="html"><![CDATA[<h4 id="hexo常用命令"><a href="#hexo常用命令" class="headerlink" title="hexo常用命令"></a>hexo常用命令</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#简写</span></span><br><span class="line">hexo n <span class="string">"我的博客"</span> == hexo new <span class="string">"我的博客"</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo g == hexo generate<span class="comment">#生成</span></span><br><span class="line">hexo s == hexo server <span class="comment">#启动服务预览</span></span><br><span class="line">hexo d == hexo deploy<span class="comment">#部署</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务器</span></span><br><span class="line">hexo server <span class="comment">#Hexo 会监视文件变动并自动更新，您无须重启服务器。</span></span><br><span class="line">hexo server -s <span class="comment">#静态模式</span></span><br><span class="line">hexo server -p <span class="number">5000</span> <span class="comment">#更改端口</span></span><br><span class="line">hexo server -i <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> <span class="comment">#自定义 IP</span></span><br><span class="line"></span><br><span class="line">hexo clean <span class="comment">#清除缓存 网页正常情况下可以忽略此条命令</span></span><br><span class="line">hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">hexo d <span class="comment">#开始部署</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#监视文件变动</span></span><br><span class="line">hexo generate <span class="comment">#使用 Hexo 生成静态文件快速而且简单</span></span><br><span class="line">hexo generate --watch <span class="comment">#监视文件变动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#草稿</span></span><br><span class="line">hexo publish [layout] &lt;title&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#模版</span></span><br><span class="line">hexo new <span class="string">"postName"</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo new page <span class="string">"pageName"</span> <span class="comment">#新建页面</span></span><br><span class="line">hexo generate <span class="comment">#生成静态页面至public目录</span></span><br><span class="line">hexo server <span class="comment">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class="line">hexo deploy <span class="comment">#将.deploy目录部署到GitHub</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">hexo new [layout] &lt;title&gt;</span><br><span class="line">hexo new photo <span class="string">"My Gallery"</span></span><br><span class="line">hexo new <span class="string">"Hello World"</span> --lang tw</span><br><span class="line"></span><br><span class="line"><span class="comment">#推送到服务器上</span></span><br><span class="line">hexo n <span class="comment">#写文章</span></span><br><span class="line">hexo g <span class="comment">#生成</span></span><br><span class="line">hexo d <span class="comment">#部署 #可与hexo g合并为 hexo d -g</span></span><br></pre></td></tr></table></figure><h4 id="简易发布流程"><a href="#简易发布流程" class="headerlink" title="简易发布流程"></a>简易发布流程</h4><p>主要是通过配置一个alias命令来实现</p><p>例如博客文件夹的路径为 C:\blog_backup，将其替换为你自己的路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> alias.fuck <span class="string">'!cd C:\\blog_backup;hexo clean;hexo g -d'</span></span><br><span class="line">git fuck</span><br></pre></td></tr></table></figure><p>在任意目录打开git bash，就能够实现上述命令集；</p><p>如果要取消alias的话，可通过以下方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset alias.fuck</span><br></pre></td></tr></table></figure><p>个人设置了几个简易的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git blogview #更新博客内容并发布到本地服务器</span><br><span class="line">git blogupdate #更新博客内容并部署到网站</span><br><span class="line">git blognew #新建博客文章，初始化名字为“new title”</span><br></pre></td></tr></table></figure><h4 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h4><ul><li><p>先将图片文件上传至bmob，获取到图片链接后，直接在markdown中添加链接</p></li><li><p>图片命名格式：文章发布年月日-当天发表文章序号-文章内图片序号（说明）  </p><p>序号以0起始</p><p>例如：20190222-0-1.png</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;hexo常用命令&quot;&gt;&lt;a href=&quot;#hexo常用命令&quot; class=&quot;headerlink&quot; title=&quot;hexo常用命令&quot;&gt;&lt;/a&gt;hexo常用命令&lt;/h4&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
      <category term="博客" scheme="http://liutaiyu.cn/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="hexo" scheme="http://liutaiyu.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络的性能</title>
    <link href="http://liutaiyu.cn/2019/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD/"/>
    <id>http://liutaiyu.cn/2019/02/22/计算机网络的性能/</id>
    <published>2019-02-22T02:21:47.000Z</published>
    <updated>2019-04-10T07:16:42.291Z</updated>
    
    <content type="html"><![CDATA[<p><strong>主要介绍常用的七个性能指标:</strong></p><h4 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h4><p>比特(bit)是计算机中数据量的单位，也是信息论中使用的信息量的单位。英文单词bit来源于binary digit，意思是一个“二进制数字”。网络技术中的速率指的是连接在计算机网络上的主机在数字信道上传送数据的速率，它也称为数据率(data rate)或比特率(bit rate)。时间的基本单位是s(秒)，因此单位是bit/s(比特/秒，有时也写作bps，即bit per second)。（1Gbit/s = 10^3Mbit/s = 10^6Kbit/s = 10^9bit/s）。</p><p><em>注意：在通信领域和计算机领域，应特别注意数量单位“千”、“兆”、“吉”等的英文缩写所代表的数值。计算机中的数量单位用字节作为度量单位，“千字节”的“千”用大写K表示，它等于2^10，即1024，而不是1000。</em></p><h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><h5 id="“带宽”有两种不同的意义："><a href="#“带宽”有两种不同的意义：" class="headerlink" title="“带宽”有两种不同的意义："></a>“带宽”有两种不同的意义：</h5><ol><li>带宽本来是指某个信号具有的频带宽度。信号的带宽是指该信号所包含的各种不同频率成份所占据的频率范围。这种意义的带宽的单位是赫。因此，表示通信线路允许通过的信号频带范围就称为线路的带宽(或通频带)。</li><li>在计算机网络中，带宽用来表示网络的通信线路传送数据的能力，因此网络带宽表示单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。这种意义的带宽的单位是比特/秒。</li></ol><p>   在“带宽”的两种表述中，前者为频域称谓，而后者为时域称谓，其本质是相同的。也就是说，一条通信链路的“带宽”越宽，其所能传输的“最高数据率”也越高。</p><p>   <em>注意：宽带运行商和电脑对宽带的速度单位是不一样的，电脑的单位是KBbs，而宽带运营商的单位是Kbbs，1B = 8b。例如你从宽带运营商那里办理了10M的宽带。  10Mbps = 10240Kbps / 8 = 1280KBps.</em></p><h5 id="上行带宽和下行带宽，或者说上行速度和下行速度是什么意思"><a href="#上行带宽和下行带宽，或者说上行速度和下行速度是什么意思" class="headerlink" title="上行带宽和下行带宽，或者说上行速度和下行速度是什么意思?"></a>上行带宽和下行带宽，或者说上行速度和下行速度是什么意思?</h5><p>   我们访问互联网的过程中存在这两种行为：一是上传数据，二是下载数据。上行宽带(速度)指的是上传的速度，而下行宽带(速度)指的是下载数据是的数度。</p><p>  上行宽带(速度)和下行宽带(速度)是不对称的，一般是下行速度大于上行的速度。我们平时所使用的宽带说多少M，都是指的下行宽带，因为我们上网主要是从互联网上下载数据，而上传的数据量要少很多。</p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>   吞吐量(throughput)表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量受网络带宽或网络的额定速率的限制。吞吐量更经常的用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。</p><h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><p>   时延(delay 或 latency)是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。时延是个很重要的性能指标。网络中的时延由以下几个不同的部分组成：</p><ol><li><strong>发送时延</strong>：指主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需要的时间。发生在机器内部的发生器中,与传输信道的长度没有任何关系。<blockquote><p>发送时延计算公式：数据帧的长度(bits) / 发送速率(bits/s)</p></blockquote></li></ol><p>由此可见发送时延与发送的帧长成正比，与发送速率成反比。</p><ol start="2"><li><strong>传播时延</strong>：指电磁波在信道中传播一定距离需要花费的时间。</li></ol><blockquote><p>传播时延计算公式：信道长度(m) / 电磁波在信道上的传播速率(m/s)</p></blockquote><blockquote><p>电磁波在自由空间传播速率是光速：3.0×10^5km/s，铜线电缆中：2.3×10^5km/s，光纤中：2.0×10^5km/s。传播时延与信号的发送速率无关。信号传送的距离越远，传播时延就越大。    </p><ol start="3"><li><strong>处理时延</strong>：主机或路由器在收到分组时要花费一定的时间进行处理，例如分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等等。</li></ol></blockquote><ol start="4"><li><strong>排队时延</strong>：分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发。这就产生了排队时延。<blockquote><p>总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</p></blockquote></li></ol><p><em>注意：由于时延由以上四部分组成，所以不能笼统地认为：“数据的发送速率越高，传送得就越快”。同时需要特别注意一个错误观念：“在高速链路，比特应当跑得更快些”。这是不对的，因为对于高速网络链路，我们提高的仅仅是数据的发送速率，而不是比特在链路上的传播速率。提高数据的发送速率只是减少了数据的发送时延。而传播速率的单位是每秒传输多少公里，是指传输线路上比特的传播速率，通常是由线路决定而不变的。</em></p><h4 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h4><blockquote><p>时延带宽积 = 传播时延 × 带宽</p></blockquote><p>时延带宽积表示链路可容纳的比特数，因此，链路的时延带宽积又称为以比特为单位的链路长度。</p><h4 id="往返时间RTT"><a href="#往返时间RTT" class="headerlink" title="往返时间RTT"></a>往返时间RTT</h4><p>  往返时间RTT，表示从发送方发送数据开始，到发送方收到来自接收方的确认（接收方收到数据后便立即发送确认），总共经历的时间。往返时间一般就会包括分组在网络中的各种时延。</p><h4 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h4><p>利用率由信道利用率和网络利用率两种。信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。网络的利用率则是全网络的信道利用率的加权平均值。信道利用率并非越高越好，这是因为，根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也会迅速增加。信道或网络的利用率过高会产生非常大的时延。</p><p><img src="http://bmob-cdn-24774.b0.upaiyun.com/2019/04/10/39b6d27040a2e63b8091ce72e4dd589b.png" alt="时延与利用率的关系"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;主要介绍常用的七个性能指标:&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;速率&quot;&gt;&lt;a href=&quot;#速率&quot; class=&quot;headerlink&quot; title=&quot;速率&quot;&gt;&lt;/a&gt;速率&lt;/h4&gt;&lt;p&gt;比特(bit)是计算机中数据量的单位，也是信息论中使用的信息量
      
    
    </summary>
    
      <category term="计算机基础" scheme="http://liutaiyu.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机网络" scheme="http://liutaiyu.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>148.排序链表</title>
    <link href="http://liutaiyu.cn/2018/11/05/148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://liutaiyu.cn/2018/11/05/148-排序链表/</id>
    <published>2018-11-05T09:03:36.000Z</published>
    <updated>2019-02-28T11:25:56.912Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://leetcode-cn.com/problems/sort-list/description/" target="_blank" rel="noopener">148. 排序链表</a><br><strong>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</strong><br><strong>示例1:</strong></p><blockquote><p>输入: 4-&gt;2-&gt;1-&gt;3<br>  输出: 1-&gt;2-&gt;3-&gt;4</p></blockquote><p><strong>示例2:</strong></p><blockquote><p>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>  输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</p></blockquote><p>思路：考查链表的排序，要求的时间复杂度可以联想到快速排序、堆排序、归并排序。由于是链表，我们选择二分归并排序比较容易实现。以下是Java的两种实现。</p><p>解法一：常规的插入排序，用时较多<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode root=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        root.next=head;</span><br><span class="line">        ListNode p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>&amp;&amp;p.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val&lt;=p.next.val)&#123;p=p.next;&#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ListNode tmp=root,q=p.next;</span><br><span class="line">                <span class="keyword">while</span>(tmp.next.val&lt;=q.val)&#123;</span><br><span class="line">                    tmp=tmp.next;</span><br><span class="line">                &#125;                </span><br><span class="line">                p.next=q.next;</span><br><span class="line">                q.next=tmp.next;</span><br><span class="line">                tmp.next=q;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解法二：二分归并排序,用时较少<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">return</span> mergeSort(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">mergeSort</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"><span class="comment">//分治</span></span><br><span class="line">ListNode p1 = head;</span><br><span class="line">ListNode p2 = head;</span><br><span class="line"><span class="comment">//遍历对链表二分</span></span><br><span class="line"><span class="keyword">while</span>(p2.next!=<span class="keyword">null</span> &amp;&amp; p2.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">p1 = p1.next;</span><br><span class="line">p2 = p2.next.next;</span><br><span class="line">&#125;</span><br><span class="line">ListNode left = head; <span class="comment">//左子链</span></span><br><span class="line">ListNode right = p1.next; <span class="comment">//右子链</span></span><br><span class="line">p1.next = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//排序子链表</span></span><br><span class="line">left = mergeSort(left);</span><br><span class="line">right = mergeSort(right);</span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line"><span class="keyword">if</span>(left==<span class="keyword">null</span>) <span class="keyword">return</span> right;</span><br><span class="line"><span class="keyword">if</span>(right==<span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">ListNode h = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">ListNode p = h;</span><br><span class="line"><span class="comment">//对左右两数进行比较</span></span><br><span class="line"><span class="keyword">while</span>(left!=<span class="keyword">null</span> &amp;&amp; right!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(left.val&lt;right.val)&#123;</span><br><span class="line">p.next = left;</span><br><span class="line">left = left.next;</span><br><span class="line">p = p.next;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">p.next = right;</span><br><span class="line">right = right.next;</span><br><span class="line">p = p.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(left==<span class="keyword">null</span>) p.next = right;</span><br><span class="line"><span class="keyword">else</span> p.next = left;</span><br><span class="line"><span class="keyword">return</span> h.next; <span class="comment">//返回表头</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode-cn.com/problems/sort-list/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;148. 排序链表&lt;/a&gt;&lt;br&gt;&lt;strong&gt;在 O(n log 
      
    
    </summary>
    
      <category term="计算机基础" scheme="http://liutaiyu.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Leetcode" scheme="http://liutaiyu.cn/tags/Leetcode/"/>
    
      <category term="排序算法" scheme="http://liutaiyu.cn/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
