<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Heitu的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liutaiyu.cn/"/>
  <updated>2019-04-15T10:09:00.810Z</updated>
  <id>http://liutaiyu.cn/</id>
  
  <author>
    <name>Heitu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>决策树基础</title>
    <link href="http://liutaiyu.cn/2019/04/15/%E5%86%B3%E7%AD%96%E6%A0%91%E5%9F%BA%E7%A1%80/"/>
    <id>http://liutaiyu.cn/2019/04/15/决策树基础/</id>
    <published>2019-04-15T03:04:25.000Z</published>
    <updated>2019-04-15T10:09:00.810Z</updated>
    
    <content type="html"><![CDATA[<h3 id="决策树（Decision-Tree）"><a href="#决策树（Decision-Tree）" class="headerlink" title="决策树（Decision Tree）"></a>决策树（Decision Tree）</h3><p>决策树是一种基本的分类和回归的方法，它是一种树形结构。其每个非叶节点表示一个<strong>特征属性</strong>上的测试，每个分支代表这个特征属性在其取值范围内的某一输出，而每个叶节点存放一个<strong>类别</strong>。</p><p>决策树进行<strong>决策的过程</strong>就是从根节点开始，测试待分类项中相应的特征属性，并按照其值选择输出分支，直到到达叶子节点，将叶子节点存放的类别作为决策结果。</p><p>决策树学习本质上是从训练数据集中归纳出一组分类规则。通常用损失函数表示这一目标，损失函数通常是正则化的极大似然函数，<strong>学习的策略是以损失函数为目标函数的最小化。</strong>学习的算法一般是启发式方法，近似求解最优值。学习算法是一个递归选择最优特征的过程。为了避免最后学习到的决策树发生过拟合现象，我们通常使用验证集来对学习到的决策树进行剪枝，使其有更好的泛化能力。</p><p><img src="https://o9wdag.ch.files.1drv.com/y4mOs4BhnCR_drkQjLvsWHyugFVX8gfiPGrCOVK2PuQUD8FH9dmzbiEL3JYB4Z0GtJfTEte5u_UDkWaXC5gsV58z_NCdSWe5tSh8GljXMqqHLYNCU-TxUTuMJ02fZDhWIdDlBAn87AKmD4cU3SZfm5XdjetIDVSm-o0wNzvFNVL5UjK72EHrvZ2sWlOO4aDp_LSh6c5QYiG9MNm5RbbodT9fg?width=706&amp;height=462&amp;cropmode=none" alt="决策树结构"></p><p><strong>决策树的结构有以下特点：</strong></p><ul><li>结点和有向边组成</li><li>结点有内部结点和叶结点俩种类型</li><li>内部结点表示一个特征，叶节点表示一个类，边表示该特征下可能的输出值</li></ul><p><strong>决策树学习的步骤通常包括：</strong></p><ul><li>特征选择</li><li>决策树的生成</li><li>决策树的剪枝</li></ul><p>下面从决策树学习的三个步骤介绍决策树模型的原理：</p><h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><p>特征选择的目的在于选取对训练数据能够分类的特征，常用的特征选择算法有ID.3、C4.5和基尼系数，相关的公式如下：</p><h4 id="ID-3"><a href="#ID-3" class="headerlink" title="ID.3"></a>ID.3</h4><p>样本集合D对特征A的信息增益</p><script type="math/tex; mode=display">g(D,A)=H(D)-H(D|A)\\H(D)=-\sum_{k=1}^{K}\frac{\left | C_{k} \right |}{\left | D \right |}\log_{2}\frac{\left | C_{k} \right |}{\left | D \right |}\\H(D|A)=-\sum_{i=1}^{n}\frac{\left | D_{i} \right |}{\left | D \right |}H(D_{i})</script><p>其中$H(D)$是数据集D的熵，<script type="math/tex">H(D_i)</script>是数据集<script type="math/tex">D_i</script>的熵，$H(D|A)$是数据集D对特征A的条件熵。<script type="math/tex">D_i</script>是D中特征A取第i个值的样本子集，<script type="math/tex">C_k</script>是D中属于第k类的样本子集。n是特征A取值的个数，K是类的个数。</p><h4 id="C4-5"><a href="#C4-5" class="headerlink" title="C4.5"></a>C4.5</h4><script type="math/tex; mode=display">g_{R}(D,A)=\frac{g(D,A)}{H_{A}(D)}</script><p>其中，$g(D,A)$是信息增益，$H_{A}(D)$是D关于特征A的值的熵。</p><h4 id="CART（分类问题）"><a href="#CART（分类问题）" class="headerlink" title="CART（分类问题）"></a>CART（分类问题）</h4><script type="math/tex; mode=display">Gini(D)=1-\sum_{k=1}^{K}\left ( \frac{\left | C_{k} \right |}{\left | D \right |} \right )^2</script><p>特征A条件下集合D的基尼系数：</p><script type="math/tex; mode=display">Gini(D,A)=\frac{\left | D_{1} \right |}{\left | D \right |}Gini(D_{1})+\frac{\left | D_{2} \right |}{\left | D \right |}Gini(D_{2})</script><h3 id="决策树的生成"><a href="#决策树的生成" class="headerlink" title="决策树的生成"></a>决策树的生成</h3><p>通常使用上述特征选择的方法，从根节点开始，递归的生成决策树。这里主要讲一下CART回归树的生成，CART对<strong>回归树用平方误差最小化准则，对分类树用基尼系数最小化准则</strong>，进行特征选择，生成树。</p><h4 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h4><p>假设X,Y为输入和输出，Y为连续变量。假设我们将输入空间划分为M个单元$R_1…R_M​$，并且每个单元$R_m​$上有一个固定的输出值${c_m}​$，模型可以表示为：</p><script type="math/tex; mode=display">f(x)=\sum_{m=1}^{M}c_{m}I(x\in{R_{m}})</script><p>我们可以用平方误差<script type="math/tex">\sum_{x_{i}\in{R_{m}}}{(y_{i}-f(x_{i}))^2}​</script>来表示回归树的训练误差，易知单元<script type="math/tex">{R_m}​</script>上的<script type="math/tex">{c_m}​</script>的最优值是单元上所有输入实例对应的输出值的均值：</p><script type="math/tex; mode=display">\hat c_m=ave(y_i|x_i \in{R_m})</script><p>对于空间的划分，我们选择第j个特征$x^{(j)}$和它的取值s，并定义两个区域：</p><script type="math/tex; mode=display">R_1(j,s)=\{x|x^{(j)}\leq s\}\hspace{3em}\hat R_2(j,s)=\{x|x^{(j)}> s\}</script><p>然后求解：</p><script type="math/tex; mode=display">\min_{j,s}\left [ \min_{c_1}\sum_{x_{i}\in{R_{1}(j,s)}}(y_{i}-c_1)^2 +\min_{c_2}\sum_{x_{i}\in{R_{2}(j,s)}}(y_{i}-c_2)^2 \right ]</script><p>对于固定的输入变量j，可以找到s.</p><script type="math/tex; mode=display">\hat c_m=\frac{1}{N_m}\sum_{x_i \in{R_{m}(j,s)}}y_i\hspace{1em}(x\in R_m,m=1,2)</script><p>然后遍历j，找到最优的（j，s）对。然后依据此对空间做一次划分，重复上述过程。这样生成的树我们通常称为最小二乘回归树。<strong>每一次划分后，下一次拟合的是残差。</strong></p><h3 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h3><p>决策树的剪枝<strong>通过极小化决策树整体的Loss来实现</strong>，假设决策树T的叶节点个数为|T|，t是树T的叶节点，该叶节点有<script type="math/tex">N_t</script>个样本点，其中k类的样本点有<script type="math/tex">N_{tk}</script>个，<script type="math/tex">k=1,2,...,K</script>，<script type="math/tex">H_{t}(T)</script>为叶节点t上的经验熵，<script type="math/tex">\alpha \geq 0</script>为参数，则决策树学习的损失函数定义为：其中经验熵为：<script type="math/tex">H_{t}(T)=-\sum_{k=1}^{K}\frac{N_{tk}}{N_{t}}\log \frac{N_{tk}}{N_{t}}</script></p><script type="math/tex; mode=display">\begin{align}C_{\alpha}(T)&=\sum_{t=1}^{|T|}N_{t}H_{t}(T)+\alpha|T|\\&=-\sum_{t=1}^{|T|}\sum_{k=1}^{K}N_{tk}\log \frac{N_{tk}}{N_{t}}+\alpha|T|\\&=C(T)+\alpha|T|\end{align}</script><p>上式中C(T)表示模型对训练数据的预测误差，即模型和训练数据的拟合程度，|T|表示模型的复杂度。剪枝就是当α确定时，选择损失函数最小的模型，即损失函数最小的子树。</p><blockquote><p>算法：</p><p>输入：生成树T，参数α</p><p>输出：修剪后的子树$T_{\alpha}​$</p><ol><li>计算每个节点的经验熵</li><li>递归的从树的叶节点向上回缩，<strong>如果回缩到父节点前后的损失函数值不增加，那么进行剪枝，将父节点变为新的叶节点</strong></li><li>返回2，直至不能继续，得到损失函数最小的子树$T_{\alpha}$</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;决策树（Decision-Tree）&quot;&gt;&lt;a href=&quot;#决策树（Decision-Tree）&quot; class=&quot;headerlink&quot; title=&quot;决策树（Decision Tree）&quot;&gt;&lt;/a&gt;决策树（Decision Tree）&lt;/h3&gt;&lt;p&gt;决策树是一种
      
    
    </summary>
    
      <category term="学习" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="机器学习" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="监督学习" scheme="http://liutaiyu.cn/tags/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法模型" scheme="http://liutaiyu.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hexo中使用Latex公式</title>
    <link href="http://liutaiyu.cn/2019/04/13/Hexo%E4%B8%AD%E4%BD%BF%E7%94%A8Latex%E5%85%AC%E5%BC%8F/"/>
    <id>http://liutaiyu.cn/2019/04/13/Hexo中使用Latex公式/</id>
    <published>2019-04-13T11:47:08.000Z</published>
    <updated>2019-04-15T08:29:16.483Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>公式插入格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$数学公式$ 行内 不独占一行</span><br><span class="line">$$数学公式$$ 行间 独占一行</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$f(x)=ax+b$  #行内显示</span><br><span class="line">$$</span><br><span class="line">f(x)=ax+b    #行间显示</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>显示效果为：$f(x)=ax+b​$</p><p>行间使用则为：</p><script type="math/tex; mode=display">f(x)=ax+b</script><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><h4 id="上标与下标"><a href="#上标与下标" class="headerlink" title="上标与下标"></a>上标与下标</h4><p>使用 ^ 表示上标，使用 _ 表示下标，如果上下标的内容多于一个字符，可以使用大括号括起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$f(x) = a_1x^n + a_2x^&#123;n-1&#125; + a_3x^&#123;n-2&#125;$$</span><br></pre></td></tr></table></figure><p>显示效果为：</p><script type="math/tex; mode=display">f(x) = a_1x^n + a_2x^{n-1} + a_3x^{n-2}</script><p>如果左右两边都有上下标可以使用 \sideset 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\sideset&#123;^n_k&#125;&#123;^x_y&#125;a$$</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\sideset{^n_k}{^x_y}a</script><h4 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h4><p>在 markdown 语法中，\, $, {, }, _都是有特殊含义的，所以需要加\转义。小括号与方括号可以使用原始的() [] 大括号需要转义\也可以使用\lbrace和 \rbrace</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\&#123;x*y\&#125;</span><br><span class="line">\lbrace x*y \rbrace</span><br></pre></td></tr></table></figure><p>显示效果为：$\lbrace x*y \rbrace$</p><p>原始符号不会随着公式大小自动缩放，需要使用 \left 和 \right 来实现自动缩放：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\left \lbrace \sum_&#123;i=0&#125;^n i^3 = \frac&#123;(n^2+n)(n+6)&#125;&#123;9&#125; \right \rbrace$$</span><br></pre></td></tr></table></figure><p>效果(加上了\left 和 \right):$\left \lbrace \sum_{i=0}^n i^3 = \frac{(n^2+n)(n+6)}{9} \right \rbrace$</p><p>没加的效果：$ \lbrace \sum_{i=0}^n i^3 = \frac{(n^2+n)(n+6)}{9} \rbrace$</p><h4 id="分数与开方"><a href="#分数与开方" class="headerlink" title="分数与开方"></a>分数与开方</h4><p>可以使用\frac 或者 \over 实现分数的显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$\frac xy$</span><br><span class="line">$ x+3 \over y+5 $</span><br></pre></td></tr></table></figure><p>分别显示为：</p><p>$\frac xy$       $ x+3 \over y+5 $</p><p>开方使用\sqrt:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ \sqrt&#123;x^5&#125; $</span><br><span class="line">$ \sqrt[3]&#123;\frac xy&#125; $</span><br></pre></td></tr></table></figure><p>显示为：$ \sqrt{x^5} $     $ \sqrt[3]{\frac xy} $</p><h4 id="求和与积分"><a href="#求和与积分" class="headerlink" title="求和与积分"></a>求和与积分</h4><p>求和使用\sum,可加上下标，积分使用\int可加上下限，双重积分用\iint:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ \sum_&#123;i=0&#125;^n $</span><br><span class="line">$ \int_a ^ b $</span><br><span class="line">$ \iint_1 ^ \infty $</span><br></pre></td></tr></table></figure><p>分别显示：$ \sum_{i=0}^n $   $ \int_a^b $  $ \iint_1^\infty $</p><h4 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h4><p>极限使用\lim:       $ \lim_{x \to 0} $</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ \lim_&#123;x \to 0&#125; $</span><br></pre></td></tr></table></figure><h4 id="表格与矩阵"><a href="#表格与矩阵" class="headerlink" title="表格与矩阵"></a>表格与矩阵</h4><p>表格样式lcr表示居中，|加入一条竖线，\hline表示行间横线，列之间用&amp;分隔，行之间用\分隔：</p><script type="math/tex; mode=display">\begin{array}{c|lcr}n & \text{Left} & \text{Center} & \text{Right} \\\\\hline1 & 1.97 & 5 & 12 \\\\2 & -11 & 19 & -80 \\\\3 & 70 & 209 & 1+i \\\\\end{array}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;array&#125;&#123;c|lcr&#125;</span><br><span class="line">n &amp; \text&#123;Left&#125; &amp; \text&#123;Center&#125; &amp; \text&#123;Right&#125; \\\\</span><br><span class="line">\hline</span><br><span class="line">1 &amp; 1.97 &amp; 5 &amp; 12 \\\\</span><br><span class="line">2 &amp; -11 &amp; 19 &amp; -80 \\\\</span><br><span class="line">3 &amp; 70 &amp; 209 &amp; 1+i \\\\</span><br><span class="line">\end&#123;array&#125;$$</span><br></pre></td></tr></table></figure><p>矩阵:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$$\left[</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">V_A \\\\</span><br><span class="line">V_B \\\\</span><br><span class="line">V_C \\\\</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">\right] =</span><br><span class="line">\left[</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">1 &amp; 0 &amp; L \\\\</span><br><span class="line">-cosψ &amp; sinψ &amp; L \\\\</span><br><span class="line">-cosψ &amp; -sinψ &amp; L</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">\right]</span><br><span class="line">\left[</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">V_x \\\\</span><br><span class="line">V_y \\\\</span><br><span class="line">W \\\\</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">\right] $$</span><br></pre></td></tr></table></figure><p>显示效果：</p><script type="math/tex; mode=display">\left[\begin{matrix}V_A \\\\V_B \\\\V_C \\\\\end{matrix}\right] =\left[\begin{matrix}1 & 0 & L \\\\-cosψ & sinψ & L \\\\-cosψ & -sinψ & L\end{matrix}\right]\left[\begin{matrix}V_x \\\\V_y \\\\W \\\\\end{matrix}\right]</script><h4 id="换行问题（换行，等号对齐）"><a href="#换行问题（换行，等号对齐）" class="headerlink" title="换行问题（换行，等号对齐）"></a>换行问题（换行，等号对齐）</h4><p>公示太长需要换行的问题，并且是连等公示，每个等号在还行之后都需要对齐。 可以使用：</p><p>其中aligned就是用来公式对齐的，在中间公式中，\\ 表示换行， &amp; 表示对齐。在公式中等号之前加&amp;，等号介绍要换行的地方加\\就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;equation&#125;</span><br><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">......</span><br><span class="line">\end&#123;aligned&#125;</span><br><span class="line">\end&#123;equation&#125;</span><br><span class="line">例如：</span><br><span class="line">\begin&#123;equation*&#125;%加*表示不对公式编号</span><br><span class="line">\begin&#123;split&#125;</span><br><span class="line">PMV =&amp;[0.303*exp(-0.036M)+0.0275]*\&#123;M-W-3.05*[5.733-\\</span><br><span class="line">&amp;0.007(M-W)-P_a]-0.42*(M-W-58.2)-0.0173M*\\</span><br><span class="line">&amp;(5.867-P_a)-0.0014M*(34-t_a)-3.96*10^-8*f_cl*[(t_cl+\\</span><br><span class="line">&amp;273)^4-(t_r+273)^4]-f_cl*h_c*(t_cl-t_a)\&#125;</span><br><span class="line">\end&#123;split&#125;</span><br><span class="line">\end&#123;equation*&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{equation*}%加*表示不对公式编号\begin{split}PMV =&[0.303*exp(-0.036M)+0.0275]*\{M-W-3.05*[5.733-\\&0.007(M-W)-P_a]-0.42*(M-W-58.2)-0.0173M*\\&(5.867-P_a)-0.0014M*(34-t_a)-3.96*10^-8*f_cl*[(t_cl+\\&273)^4-(t_r+273)^4]-f_cl*h_c*(t_cl-t_a)\}\end{split}\end{equation*}</script><p>参考：<a href="http://stevenshi.me/2017/06/26/hexo-insert-formula/" target="_blank" rel="noopener">http://stevenshi.me/2017/06/26/hexo-insert-formula/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;p&gt;公式插入格式：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
      
    
    </summary>
    
      <category term="工作" scheme="http://liutaiyu.cn/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="博客" scheme="http://liutaiyu.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题集笔记</title>
    <link href="http://liutaiyu.cn/2019/04/13/%E5%89%91%E6%8C%87offer%E9%A2%98%E9%9B%86/"/>
    <id>http://liutaiyu.cn/2019/04/13/剑指offer题集/</id>
    <published>2019-04-13T03:25:30.000Z</published>
    <updated>2019-04-16T05:35:44.381Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目16：数值的整数次方"><a href="#题目16：数值的整数次方" class="headerlink" title="题目16：数值的整数次方"></a>题目16：数值的整数次方</h3><ul><li><strong>题目描述</strong></li></ul><p>给定一个double类型的浮点数base和int类型的整数exponent，求base的exponent次方。</p><ul><li><strong>分析</strong></li></ul><p>此题可以使用公式：</p><script type="math/tex; mode=display">{a^n}=\left\{\begin{matrix}{a^\frac{n}{2}}*{a^\frac{n}{2}},n为偶数\\{a^\frac{n-1}{2}}*{a^\frac{n-1}{2}}*a,n为奇数\end{matrix}\right.</script><p>来求解a的n次幂，目的是可以减小乘法的次数，另外需要判断当幂指数不大于0和底数为0时的边界条件。</p><ul><li><strong>参考实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>((exponent&amp;<span class="number">1</span>)==<span class="number">1</span>)res=base;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">true</span>; <span class="comment">//标识位幂指数是否为负</span></span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)&#123;<span class="comment">//转为正幂指数</span></span><br><span class="line">            <span class="keyword">if</span>(base==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            flag=<span class="keyword">false</span>;</span><br><span class="line">            exponent*=-<span class="number">1</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">double</span> tmp=base*base;</span><br><span class="line">        <span class="keyword">while</span>(exponent&gt;<span class="number">1</span>)&#123;<span class="comment">//求乘法</span></span><br><span class="line">            res*=tmp;</span><br><span class="line">            tmp=res;</span><br><span class="line">            exponent = exponent&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag?res:<span class="number">1</span>/res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="题目21：调整数组数顺序使奇数位于偶数前面"><a href="#题目21：调整数组数顺序使奇数位于偶数前面" class="headerlink" title="题目21：调整数组数顺序使奇数位于偶数前面"></a>题目21：调整数组数顺序使奇数位于偶数前面</h3><ul><li><strong>题目描述</strong></li></ul><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><ul><li><strong>分析</strong></li></ul><p>该题和原书中的题有一点不一样，本题要求保证数组元素的稳定。书中最简单的方法是从头到尾扫描数组，碰到一个偶数，拿出来放到数组末尾，其他元素向前移动一位。没碰到一个偶数我们就要移动$O\left ( n \right )$该方法时间复杂度为$O\left ( n^{2} \right )$。书中改进的方法是设置两个指针分别指向数组两端，如果碰到奇数偶数对，那么交换。这种方法显然是不稳定的。</p><ul><li><strong>参考实现</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReorderOddEven_1</span><span class="params">(<span class="keyword">int</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pData == <span class="literal">nullptr</span> || length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *pBegin = pData;</span><br><span class="line">    <span class="keyword">int</span> *pEnd = pData + length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pBegin &lt; pEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 向后移动pBegin，直到它指向偶数</span></span><br><span class="line">        <span class="keyword">while</span>(pBegin &lt; pEnd &amp;&amp; (*pBegin &amp; <span class="number">0x1</span>) != <span class="number">0</span>)</span><br><span class="line">            pBegin ++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向前移动pEnd，直到它指向奇数</span></span><br><span class="line">        <span class="keyword">while</span>(pBegin &lt; pEnd &amp;&amp; (*pEnd &amp; <span class="number">0x1</span>) == <span class="number">0</span>)</span><br><span class="line">            pEnd --;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pBegin &lt; pEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = *pBegin;</span><br><span class="line">            *pBegin = *pEnd;</span><br><span class="line">            *pEnd = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述书中的方法可以将while中对奇偶数的判断条件改成判定函数，则可以拓展代码的重用性。实现在给定的条件下，将数组划分成两部分。针对本题，考虑到稳定性，可以建一个队列，循环3次，分别将奇数、偶数打入队列，然后将队列输出修改原数组。时间复杂度是$3O\left( n\right)$，空间复杂度是$O\left(n\right)​$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((array[i]&amp;<span class="number">1</span>)==<span class="number">1</span>)queue.offer(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((array[i]&amp;<span class="number">1</span>)==<span class="number">0</span>)queue.offer(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            array[i]=queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="题目22：链表中倒数第k个结点"><a href="#题目22：链表中倒数第k个结点" class="headerlink" title="题目22：链表中倒数第k个结点"></a>题目22：链表中倒数第k个结点</h3><ul><li><strong>题目描述</strong></li></ul><p>输入一个链表，输出该链表中倒数第k个结点。</p><ul><li><strong>分析</strong></li></ul><p>该题最简单的思路是遍历两次，一次求得链表长度，第二次找到倒数第k个点。优化的办法是，设置两个指针，第一个指针遍历到第k-1个节点，第二个指针再从头开始，两个指针同时扫描直至第一个指针到达链表末尾。此时第二个指针指向的就是倒数第K个节点。</p><p>这中间有几个边界条件需要特别注意：</p><ol><li>输入链表为空</li><li>输入k为0</li><li>链表节点个数小于K</li></ol><ul><li><strong>参考实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||k==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode front=head;</span><br><span class="line">        ListNode last;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(front.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                front=front.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        last=head;</span><br><span class="line">        <span class="keyword">while</span>(front.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            last=last.next;</span><br><span class="line">            front=front.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="题目24：反转链表"><a href="#题目24：反转链表" class="headerlink" title="题目24：反转链表"></a>题目24：反转链表</h3><ul><li><strong>题目描述</strong></li></ul><p>输入一个链表，反转链表后，输出新链表的表头。</p><ul><li><strong>分析</strong></li></ul><p>a-&gt;b-&gt;c-&gt;d…h-&gt;i-&gt;j-&gt;…</p><p>a&lt;-b&lt;-c&lt;-d…h&lt;-i   j-&gt;…</p><p>该问题关键在解决反转链表后的断裂怎么处理，我们用三个指针来处理。</p><ul><li><strong>参考实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode now = <span class="keyword">null</span>;     \\指向当前操作的节点</span><br><span class="line">        ListNode front = head;   \\指向下一个操作的节点</span><br><span class="line">        ListNode res=<span class="keyword">null</span>;       \\指向反转链表的尾结点</span><br><span class="line">        <span class="keyword">while</span>(front!=<span class="keyword">null</span>)&#123;      \\判断是否到达尾结点</span><br><span class="line">            now=front;           \\获得本轮操作节点</span><br><span class="line">            front=front.next;    \\front指向下一个节点，解决链表断裂</span><br><span class="line">            \\反转节点</span><br><span class="line">            now.next=res;</span><br><span class="line">            res=now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="题目25：合并两个排序的链表"><a href="#题目25：合并两个排序的链表" class="headerlink" title="题目25：合并两个排序的链表"></a>题目25：合并两个排序的链表</h3><ul><li><strong>题目描述</strong></li></ul><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><ul><li><strong>分析</strong></li></ul><p>链表合并的过程如下图所示：</p><p><img src="https://qtz5aq.ch.files.1drv.com/y4ma1HbikeYEQ_RqZxLokCR41f8eSRTJaqAI6BYlOpCxAnI6ZJRRCBurti5F9zfWZvVp8rGrjawlWw2AHN1VWft2Ld9CnLIzbZtrv30EduoGdUQjqVQfdA0jlQKdbfvIelfBZzMN9ys0az5YazAB3wKcSCXK2QQwwONxpTCOsrSixzMksQBd1iert12RyyuNT1R2AlL4G3Opv8aCxsh_IiqCg?width=2691&amp;height=2355&amp;cropmode=none" alt="链表合并过程"></p><p>a&lt;-b&lt;-c&lt;-d…h&lt;-i   j-&gt;…可以用递归实现</p><p>每一次都是选择两个链表中较小值的节点作为合并链表的头结点，然后我们再将上一次合并链表的尾结点与本次的头结点链接起来，就可以得到合并的链表。具体实现，用递归是最简单的。时间复杂度为<script type="math/tex">O(list1.length+list2.lenght)</script></p><ul><li><strong>参考实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="keyword">null</span>)<span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(list2==<span class="keyword">null</span>)<span class="keyword">return</span> list1;</span><br><span class="line">        ListNode res=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">            res=list1;</span><br><span class="line">            res.next=Merge(list1.next,list2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res=list2;</span><br><span class="line">            res.next=Merge(list1,list2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="题目26：树的子结构"><a href="#题目26：树的子结构" class="headerlink" title="题目26：树的子结构"></a>题目26：树的子结构</h3><ul><li><strong>题目描述</strong></li></ul><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><ul><li><strong>分析</strong></li></ul><p>本题实际上考察的是树的遍历和树指针的操作，同时还有遍历过程中边界条件的处理。问题可以分成两步：</p><ul><li>在A中找到与B根节点相同的节点；此步骤我们只需要遍历A树即可，我们任意选择一种树的遍历的方法即可，此处我们选择实现较为简单的递归遍历。遍历的边界条件是不能为空树；</li><li><p>判断A中该节点的子树和B是否有相同的结构；当我们能够遍历到B树的子节点的时候，代表两个子树有相同的结构。我们分别遍历左子树和右子树，当两个子树都有相同结构时，返回true，否则返回false。</p></li><li><p><strong>参考实现</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;    </span></span><br><span class="line"><span class="comment">int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1!=<span class="keyword">null</span>&amp;&amp;root2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root1.val==root2.val)res=help(root1,root2);</span><br><span class="line">            <span class="keyword">if</span>(!res)res=HasSubtree(root1.left,root2);</span><br><span class="line">            <span class="keyword">if</span>(!res)res=HasSubtree(root1.right,root2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">help</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root2==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1.val!=root2.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> help(root1.left,root2.left)&amp;&amp;help(root1.right,root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="题目27：二叉树的镜像"><a href="#题目27：二叉树的镜像" class="headerlink" title="题目27：二叉树的镜像"></a>题目27：二叉树的镜像</h3><ul><li><strong>题目描述</strong></li></ul><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><p>输入描述：</p><blockquote><p>二叉树的镜像定义：源二叉树<br>            8<br>           /  \<br>          6   10<br>         /  \   /   \<br>        5  7 9   11<br>    镜像二叉树<br>            8<br>           /  \<br>        10   6<br>            /  \   /  \<br>          11  9 7  5</p></blockquote><ul><li><strong>分析</strong></li></ul><p>本题实际上考察的是树的遍历，问题大致过程如下：</p><p>先前序遍历树的每个节点，当节点不是叶节点的时候，就交换两个子节点。要注意的是，虽然在遍历过程中对子节点进行了交换，但是递归的调用栈的顺序为前序遍历的顺序，不会改变。可以用递归直接实现，也可以借助队列循环实现。</p><ul><li><strong>参考实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror1</span><span class="params">(TreeNode root)</span> </span>&#123;  \\递归实现</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>||root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeNode tmp=root.left;</span><br><span class="line">            root.left=root.right;</span><br><span class="line">            root.right=tmp;</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)Mirror(root.left);</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)Mirror(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror2</span><span class="params">(TreeNode root)</span> </span>&#123;\\循环实现</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode now=queue.peek();</span><br><span class="line">            <span class="keyword">if</span>(now.left!=<span class="keyword">null</span>||now.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                TreeNode tmp=now.left;</span><br><span class="line">                now.left=now.right;</span><br><span class="line">                now.right=tmp;</span><br><span class="line">                queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(now.left!=<span class="keyword">null</span>)queue.offer(now.left);</span><br><span class="line">                <span class="keyword">if</span>(now.right!=<span class="keyword">null</span>)queue.offer(now.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="题目28：对称的二叉树"><a href="#题目28：对称的二叉树" class="headerlink" title="题目28：对称的二叉树"></a>题目28：对称的二叉树</h3><ul><li><strong>题目描述</strong></li></ul><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><ul><li><strong>分析</strong></li></ul><p>本题实际上考察的是树的遍历过程。树的前序、中序和后序遍历都是先访问左子树，然后再访问右子树。在本题中，我们不难发现，先访问右子树再访问左子树遍历得到的序列和原来先左后右遍历得到的序列应该相同。但是有一种特殊情况，就是树的所有节点的值相同，他们的输出序列永远相同。这个时候考虑树中空节点的情况，两种遍历方式中，遍历到某个位置的时候，两个位置要么相同，要么同时为空，否则就不对称。</p><ul><li><strong>参考实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(pRoot,pRoot);\\让树分别从左子树和右子树两个方向遍历</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode p1,TreeNode p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1==<span class="keyword">null</span>&amp;&amp;p2==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p1==<span class="keyword">null</span>||p2==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p1.val!=p2.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(p1.left,p2.right)&amp;&amp;isSymmetrical(p1.right,p2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目16：数值的整数次方&quot;&gt;&lt;a href=&quot;#题目16：数值的整数次方&quot; class=&quot;headerlink&quot; title=&quot;题目16：数值的整数次方&quot;&gt;&lt;/a&gt;题目16：数值的整数次方&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/l
      
    
    </summary>
    
      <category term="学习" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法与数据结构" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法题目" scheme="http://liutaiyu.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>华为实习生春招笔试（二）</title>
    <link href="http://liutaiyu.cn/2019/04/10/%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E7%94%9F%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://liutaiyu.cn/2019/04/10/华为实习生春招笔试（二）/</id>
    <published>2019-04-10T14:36:50.000Z</published>
    <updated>2019-04-11T00:54:56.375Z</updated>
    
    <content type="html"><![CDATA[<p>机试一共三道题：该题为其中第二道</p><p>题目描述：</p><blockquote><p>给定一个字符串，字符串包含数字、大小写字母以及括号（包括大括号、中括号和小括号），括号可以嵌套。默认括号是匹配的，数字后面一定有括号。按照以下规则展开字符串：</p><ol><li>数字表示括号里的字符串重复的次数，展开后的字符串不包括括号。</li><li>将字符串逆序展开</li></ol></blockquote><p>输入描述：</p><blockquote><p>输入一个长度小于100的字符串</p></blockquote><p>输出描述：</p><blockquote><p>输出展开后的字符串</p></blockquote><p>示例：</p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abc3(A)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAAcba</span><br></pre></td></tr></table></figure><p>思路：该题可以联想到数学式的混合运算的实现，借助栈来判断是否对当前数进行运算。本题中则是借助栈来判断是否对子结构进行一次字符串展开，子结构为: num（string）;算法思路如下：</p><ol><li>从左至右遍历字符串，如果没有遇到右括号，则入栈。</li><li>当遇到右括号时，将其与左括号之间的字符出栈并存入临时字符串，并且重复n次</li><li>将展开后的字符串入栈，重复1，直至遍历结束。</li><li>将栈中的字符串弹出，即为展开后的逆序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String input = sc.nextLine();</span><br><span class="line"></span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(input==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; input.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(input.charAt(i) == <span class="string">']'</span> </span><br><span class="line">               || input.charAt(i) == <span class="string">')'</span> </span><br><span class="line">               || input.charAt(i) == <span class="string">'&#125;'</span>)&#123;</span><br><span class="line">                String t = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">while</span> (!stack.peek().equals(<span class="string">"("</span>)</span><br><span class="line">                       &amp;&amp;!stack.peek().equals(<span class="string">"["</span>)</span><br><span class="line">                       &amp;&amp;!stack.peek().equals(<span class="string">"&#123;"</span>)) &#123;</span><br><span class="line">                    t = t + stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">int</span> s = Integer.valueOf(stack.pop());</span><br><span class="line">                String tmp =<span class="string">""</span>;</span><br><span class="line">                <span class="keyword">while</span> (s--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    tmp +=t;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(tmp);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(String.valueOf(input.charAt(i++)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            res = res + stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;机试一共三道题：该题为其中第二道&lt;/p&gt;
&lt;p&gt;题目描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个字符串，字符串包含数字、大小写字母以及括号（包括大括号、中括号和小括号），括号可以嵌套。默认括号是匹配的，数字后面一定有括号。按照以下规则展开字符串：&lt;/p&gt;
&lt;ol
      
    
    </summary>
    
      <category term="学习" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法与数据结构" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法题目" scheme="http://liutaiyu.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>华为实习生春招笔试（一）</title>
    <link href="http://liutaiyu.cn/2019/04/10/%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E7%94%9F%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://liutaiyu.cn/2019/04/10/华为实习生春招笔试（一）/</id>
    <published>2019-04-10T13:59:50.000Z</published>
    <updated>2019-04-11T00:54:56.375Z</updated>
    
    <content type="html"><![CDATA[<p>机试一共三道题：该题为其中第一道</p><p>题目描述：</p><blockquote><p>给定n个字符串，对字符串按序每8个字符分割出一个子串，对于原字符串或者分割剩余的字符串长度不足8的，在末尾补0。要求按照自然排序输出所有新的字符串。</p></blockquote><p>输入描述：</p><blockquote><p>输入一个整数n，在输入n个字符串，相互之间空格隔开。</p></blockquote><p>输出描述：</p><blockquote><p>输出规定的字符串</p></blockquote><p>示例：</p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 abc 123456789</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12345678 90000000 abc00000</span><br></pre></td></tr></table></figure><p>思路：主要是字符串的操作和字符串长度以及边界条件的问题。对于每个字符串按要求将分割的子串添加到数组末尾，并删除当前字符串。最后排序输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            strings.add(sc.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = strings.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;size; i++) &#123;</span><br><span class="line">            <span class="comment">//System.out.println(strings);</span></span><br><span class="line">            String tmp = strings.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> l = tmp.length();</span><br><span class="line">            <span class="keyword">int</span> s = l/<span class="number">8</span>;</span><br><span class="line">            <span class="keyword">int</span> ladd = <span class="number">8</span>-l%<span class="number">8</span>;</span><br><span class="line">            <span class="keyword">if</span>(ladd==<span class="number">8</span>)ladd=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s&lt;<span class="number">1</span>||ladd==<span class="number">0</span>&amp;&amp;s==<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">                strings.add(tmp.substring(<span class="number">8</span> * j, <span class="number">8</span> * (j+<span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            String last = s&lt;<span class="number">1</span>||ladd==<span class="number">0</span>&amp;&amp;s==<span class="number">1</span>?tmp:tmp.substring(s*<span class="number">8</span>);</span><br><span class="line">            <span class="keyword">while</span> (ladd-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                last = last + <span class="string">"0"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            strings.add(last);</span><br><span class="line">            strings.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] str = strings.stream().toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">        Arrays.sort(str);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;str.length-<span class="number">1</span>)</span><br><span class="line">                System.out.print(str[i]+<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.print(str[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;机试一共三道题：该题为其中第一道&lt;/p&gt;
&lt;p&gt;题目描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定n个字符串，对字符串按序每8个字符分割出一个子串，对于原字符串或者分割剩余的字符串长度不足8的，在末尾补0。要求按照自然排序输出所有新的字符串。&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="学习" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法与数据结构" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法题目" scheme="http://liutaiyu.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>博客相关问题</title>
    <link href="http://liutaiyu.cn/2019/04/10/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://liutaiyu.cn/2019/04/10/博客相关问题/</id>
    <published>2019-04-10T07:52:36.000Z</published>
    <updated>2019-04-13T10:45:08.273Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#简写</span></span><br><span class="line">hexo n <span class="string">"我的博客"</span> == hexo new <span class="string">"我的博客"</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo g == hexo generate<span class="comment">#生成</span></span><br><span class="line">hexo s == hexo server <span class="comment">#启动服务预览</span></span><br><span class="line">hexo d == hexo deploy<span class="comment">#部署</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务器</span></span><br><span class="line">hexo server <span class="comment">#Hexo 会监视文件变动并自动更新，您无须重启服务器。</span></span><br><span class="line">hexo server -s <span class="comment">#静态模式</span></span><br><span class="line">hexo server -p <span class="number">5000</span> <span class="comment">#更改端口</span></span><br><span class="line">hexo server -i <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> <span class="comment">#自定义 IP</span></span><br><span class="line"></span><br><span class="line">hexo clean <span class="comment">#清除缓存 网页正常情况下可以忽略此条命令</span></span><br><span class="line">hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">hexo d <span class="comment">#开始部署</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#监视文件变动</span></span><br><span class="line">hexo generate <span class="comment">#使用 Hexo 生成静态文件快速而且简单</span></span><br><span class="line">hexo generate --watch <span class="comment">#监视文件变动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#草稿</span></span><br><span class="line">hexo publish [layout] &lt;title&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#模版</span></span><br><span class="line">hexo new <span class="string">"postName"</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo new page <span class="string">"pageName"</span> <span class="comment">#新建页面</span></span><br><span class="line">hexo generate <span class="comment">#生成静态页面至public目录</span></span><br><span class="line">hexo server <span class="comment">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class="line">hexo deploy <span class="comment">#将.deploy目录部署到GitHub</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">hexo new [layout] &lt;title&gt;</span><br><span class="line">hexo new photo <span class="string">"My Gallery"</span></span><br><span class="line">hexo new <span class="string">"Hello World"</span> --lang tw</span><br><span class="line"></span><br><span class="line"><span class="comment">#推送到服务器上</span></span><br><span class="line">hexo n <span class="comment">#写文章</span></span><br><span class="line">hexo g <span class="comment">#生成</span></span><br><span class="line">hexo d <span class="comment">#部署 #可与hexo g合并为 hexo d -g</span></span><br></pre></td></tr></table></figure><h4 id="简易发布流程"><a href="#简易发布流程" class="headerlink" title="简易发布流程"></a>简易发布流程</h4><p>主要是通过配置一个alias命令来实现</p><p>例如博客文件夹的路径为 C:\blog_backup，将其替换为你自己的路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> alias.fuck <span class="string">'!cd C:\\blog_backup;hexo clean;hexo g -d'</span></span><br><span class="line">git fuck</span><br></pre></td></tr></table></figure><p>在任意目录打开git bash，就能够实现上述命令集；</p><p>如果要取消alias的话，可通过以下方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset alias.fuck</span><br></pre></td></tr></table></figure><p>个人设置了几个简易的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git blogview #更新博客内容并发布到本地服务器</span><br><span class="line">git blogupdate #更新博客内容并部署到网站</span><br><span class="line">git blognew #新建博客文章，初始化名字为“new title”</span><br></pre></td></tr></table></figure><h4 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h4><ul><li><p>先将图片文件上传至<a href="https://www.bmob.cn/" target="_blank" rel="noopener">bmob</a>，获取到图片链接后，直接在markdown中添加链接</p></li><li><p>图片命名格式：文章发布年月日-当天发表文章序号-文章内图片序号（说明）  </p><p>序号以0起始</p><p>例如：20190222-0-1.png</p></li></ul><h4 id="文章分类结构"><a href="#文章分类结构" class="headerlink" title="文章分类结构"></a>文章分类结构</h4><p>文章主类分为：学习、工作、生活、爱好</p><p>标签可自行添加</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Hexo常用命令&quot;&gt;&lt;a href=&quot;#Hexo常用命令&quot; class=&quot;headerlink&quot; title=&quot;Hexo常用命令&quot;&gt;&lt;/a&gt;Hexo常用命令&lt;/h4&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
      <category term="工作" scheme="http://liutaiyu.cn/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="博客" scheme="http://liutaiyu.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络的性能</title>
    <link href="http://liutaiyu.cn/2019/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD/"/>
    <id>http://liutaiyu.cn/2019/02/22/计算机网络的性能/</id>
    <published>2019-02-22T02:21:47.000Z</published>
    <updated>2019-04-15T07:41:02.329Z</updated>
    
    <content type="html"><![CDATA[<p><strong>主要介绍常用的七个性能指标:</strong></p><h4 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h4><p>比特(bit)是计算机中数据量的单位，也是信息论中使用的信息量的单位。英文单词bit来源于binary digit，意思是一个“二进制数字”。网络技术中的速率指的是连接在计算机网络上的主机在数字信道上传送数据的速率，它也称为数据率(data rate)或比特率(bit rate)。时间的基本单位是s(秒)，因此单位是bit/s(比特/秒，有时也写作bps，即bit per second)。（1Gbit/s = 10^3Mbit/s = 10^6Kbit/s = 10^9bit/s）。</p><p><em>注意：在通信领域和计算机领域，应特别注意数量单位“千”、“兆”、“吉”等的英文缩写所代表的数值。计算机中的数量单位用字节作为度量单位，“千字节”的“千”用大写K表示，它等于2^10，即1024，而不是1000。</em></p><h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><h5 id="“带宽”有两种不同的意义："><a href="#“带宽”有两种不同的意义：" class="headerlink" title="“带宽”有两种不同的意义："></a>“带宽”有两种不同的意义：</h5><ol><li>带宽本来是指某个信号具有的频带宽度。信号的带宽是指该信号所包含的各种不同频率成份所占据的频率范围。这种意义的带宽的单位是赫。因此，表示通信线路允许通过的信号频带范围就称为线路的带宽(或通频带)。</li><li>在计算机网络中，带宽用来表示网络的通信线路传送数据的能力，因此网络带宽表示单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。这种意义的带宽的单位是比特/秒。</li></ol><p>   在“带宽”的两种表述中，前者为频域称谓，而后者为时域称谓，其本质是相同的。也就是说，一条通信链路的“带宽”越宽，其所能传输的“最高数据率”也越高。</p><p>   <em>注意：宽带运行商和电脑对宽带的速度单位是不一样的，电脑的单位是KBbs，而宽带运营商的单位是Kbbs，1B = 8b。例如你从宽带运营商那里办理了10M的宽带。  10Mbps = 10240Kbps / 8 = 1280KBps.</em></p><h5 id="上行带宽和下行带宽，或者说上行速度和下行速度是什么意思"><a href="#上行带宽和下行带宽，或者说上行速度和下行速度是什么意思" class="headerlink" title="上行带宽和下行带宽，或者说上行速度和下行速度是什么意思?"></a>上行带宽和下行带宽，或者说上行速度和下行速度是什么意思?</h5><p>   我们访问互联网的过程中存在这两种行为：一是上传数据，二是下载数据。上行宽带(速度)指的是上传的速度，而下行宽带(速度)指的是下载数据是的数度。</p><p>  上行宽带(速度)和下行宽带(速度)是不对称的，一般是下行速度大于上行的速度。我们平时所使用的宽带说多少M，都是指的下行宽带，因为我们上网主要是从互联网上下载数据，而上传的数据量要少很多。</p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>   吞吐量(throughput)表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量受网络带宽或网络的额定速率的限制。吞吐量更经常的用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。</p><h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><p>   时延(delay 或 latency)是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。时延是个很重要的性能指标。网络中的时延由以下几个不同的部分组成：</p><ol><li><strong>发送时延</strong>：指主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需要的时间。发生在机器内部的发生器中,与传输信道的长度没有任何关系。<blockquote><p>发送时延计算公式：数据帧的长度(bits) / 发送速率(bits/s)</p></blockquote></li></ol><p>由此可见发送时延与发送的帧长成正比，与发送速率成反比。</p><ol><li><strong>传播时延</strong>：指电磁波在信道中传播一定距离需要花费的时间。</li></ol><blockquote><p>传播时延计算公式：信道长度(m) / 电磁波在信道上的传播速率(m/s)</p><p>电磁波在自由空间传播速率是光速：3.0×10^5km/s，铜线电缆中：2.3×10^5km/s，光纤中：2.0×10^5km/s。传播时延与信号的发送速率无关。信号传送的距离越远，传播时延就越大。    </p><ol><li><strong>处理时延</strong>：主机或路由器在收到分组时要花费一定的时间进行处理，例如分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等等。</li></ol></blockquote><ol><li><strong>排队时延</strong>：分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发。这就产生了排队时延。<blockquote><p>总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</p></blockquote></li></ol><p><em>注意：由于时延由以上四部分组成，所以不能笼统地认为：“数据的发送速率越高，传送得就越快”。同时需要特别注意一个错误观念：“在高速链路，比特应当跑得更快些”。这是不对的，因为对于高速网络链路，我们提高的仅仅是数据的发送速率，而不是比特在链路上的传播速率。提高数据的发送速率只是减少了数据的发送时延。而传播速率的单位是每秒传输多少公里，是指传输线路上比特的传播速率，通常是由线路决定而不变的。</em></p><h4 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h4><blockquote><p>时延带宽积 = 传播时延 × 带宽</p></blockquote><p>时延带宽积表示链路可容纳的比特数，因此，链路的时延带宽积又称为以比特为单位的链路长度。</p><h4 id="往返时间RTT"><a href="#往返时间RTT" class="headerlink" title="往返时间RTT"></a>往返时间RTT</h4><p>  往返时间RTT，表示从发送方发送数据开始，到发送方收到来自接收方的确认（接收方收到数据后便立即发送确认），总共经历的时间。往返时间一般就会包括分组在网络中的各种时延。</p><h4 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h4><p>利用率由信道利用率和网络利用率两种。信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。网络的利用率则是全网络的信道利用率的加权平均值。信道利用率并非越高越好，这是因为，根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也会迅速增加。信道或网络的利用率过高会产生非常大的时延。</p><p><img src="https://o9zqaq.ch.files.1drv.com/y4mjZRdZUMMm4JDkX4UaejxiStQ9acRYtOaOmPO1JjLPj-BZJ-rwKY9HkNTP3EI5vit2Rdod1POexWkevjduoXcXF6MrzLsPwmUvF1jWxv6g8R4Zt2rOrKzehAKIOKmbgmCwlfPrtPL6JnsxnlXvCBWd9A3JC_95-MSixJqP7rd9OiHTSlkndTeHF2LZ5Y7tpwPRdC6AEWuPMRmbchV3vhpFA?width=368&amp;height=267&amp;cropmode=none" alt="时延与利用率的关系"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;主要介绍常用的七个性能指标:&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;速率&quot;&gt;&lt;a href=&quot;#速率&quot; class=&quot;headerlink&quot; title=&quot;速率&quot;&gt;&lt;/a&gt;速率&lt;/h4&gt;&lt;p&gt;比特(bit)是计算机中数据量的单位，也是信息论中使用的信息量
      
    
    </summary>
    
      <category term="学习" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="计算机基础" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机网络" scheme="http://liutaiyu.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode148-排序链表</title>
    <link href="http://liutaiyu.cn/2018/11/05/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://liutaiyu.cn/2018/11/05/LeetCode148-排序链表/</id>
    <published>2018-11-05T09:03:36.000Z</published>
    <updated>2019-04-14T09:32:55.376Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://leetcode-cn.com/problems/sort-list/description/" target="_blank" rel="noopener">148. 排序链表</a><br><strong>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</strong><br><strong>示例1:</strong></p><blockquote><p>输入: 4-&gt;2-&gt;1-&gt;3<br>  输出: 1-&gt;2-&gt;3-&gt;4</p></blockquote><p><strong>示例2:</strong></p><blockquote><p>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>  输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</p></blockquote><p>思路：考查链表的排序，要求的时间复杂度可以联想到快速排序、堆排序、归并排序。由于是链表，我们选择二分归并排序比较容易实现。以下是Java的两种实现。</p><p>解法一：常规的插入排序，用时较多<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode root=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        root.next=head;</span><br><span class="line">        ListNode p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>&amp;&amp;p.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val&lt;=p.next.val)&#123;p=p.next;&#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ListNode tmp=root,q=p.next;</span><br><span class="line">                <span class="keyword">while</span>(tmp.next.val&lt;=q.val)&#123;</span><br><span class="line">                    tmp=tmp.next;</span><br><span class="line">                &#125;                </span><br><span class="line">                p.next=q.next;</span><br><span class="line">                q.next=tmp.next;</span><br><span class="line">                tmp.next=q;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解法二：二分归并排序,用时较少<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">return</span> mergeSort(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">mergeSort</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"><span class="comment">//分治</span></span><br><span class="line">ListNode p1 = head;</span><br><span class="line">ListNode p2 = head;</span><br><span class="line"><span class="comment">//遍历对链表二分</span></span><br><span class="line"><span class="keyword">while</span>(p2.next!=<span class="keyword">null</span> &amp;&amp; p2.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">p1 = p1.next;</span><br><span class="line">p2 = p2.next.next;</span><br><span class="line">&#125;</span><br><span class="line">ListNode left = head; <span class="comment">//左子链</span></span><br><span class="line">ListNode right = p1.next; <span class="comment">//右子链</span></span><br><span class="line">p1.next = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//排序子链表</span></span><br><span class="line">left = mergeSort(left);</span><br><span class="line">right = mergeSort(right);</span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line"><span class="keyword">if</span>(left==<span class="keyword">null</span>) <span class="keyword">return</span> right;</span><br><span class="line"><span class="keyword">if</span>(right==<span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">ListNode h = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">ListNode p = h;</span><br><span class="line"><span class="comment">//对左右两数进行比较</span></span><br><span class="line"><span class="keyword">while</span>(left!=<span class="keyword">null</span> &amp;&amp; right!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(left.val&lt;right.val)&#123;</span><br><span class="line">p.next = left;</span><br><span class="line">left = left.next;</span><br><span class="line">p = p.next;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">p.next = right;</span><br><span class="line">right = right.next;</span><br><span class="line">p = p.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(left==<span class="keyword">null</span>) p.next = right;</span><br><span class="line"><span class="keyword">else</span> p.next = left;</span><br><span class="line"><span class="keyword">return</span> h.next; <span class="comment">//返回表头</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode-cn.com/problems/sort-list/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;148. 排序链表&lt;/a&gt;&lt;br&gt;&lt;strong&gt;在 O(n log 
      
    
    </summary>
    
      <category term="学习" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法与数据结构" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法题目" scheme="http://liutaiyu.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
</feed>
