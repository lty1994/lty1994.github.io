<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Heitu的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://liutaiyu.cn/"/>
  <updated>2019-04-24T04:05:21.668Z</updated>
  <id>http://liutaiyu.cn/</id>
  
  <author>
    <name>Heitu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode51-N皇后</title>
    <link href="http://liutaiyu.cn/2019/04/24/LeetCode51-N%E7%9A%87%E5%90%8E/"/>
    <id>http://liutaiyu.cn/2019/04/24/LeetCode51-N皇后/</id>
    <published>2019-04-24T03:12:36.000Z</published>
    <updated>2019-04-24T04:05:21.668Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目：51-N皇后问题"><a href="#题目：51-N皇后问题" class="headerlink" title="题目：51-N皇后问题"></a>题目：<a href="https://leetcode-cn.com/problems/n-queens/&gt;/" target="_blank" rel="noopener">51-N皇后问题</a></h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><strong>题目描述</strong></h3><p><em>n</em> 皇后问题研究的是如何将 <em>n</em> 个皇后放置在 <em>n</em>×<em>n</em> 的棋盘上，并且使皇后彼此之间不能相互攻击。这个问题的由来其实是<a href="https://zh.wikipedia.org/zh-hans/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">八皇后问题</a>，这个问题非常经典。</p><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/8-queens.png" alt="8皇后问题"></p><p>上图为 8 皇后问题的一种解法。</p><p>给定一个整数 <em>n</em>，返回所有不同的 <em>n</em> 皇后问题的解决方案。每一种解法包含一个明确的 <em>n</em> 皇后问题的棋子放置方案，该方案中 <code>&#39;Q&#39;</code> 和 <code>&#39;.&#39;</code> 分别代表了皇后和空位。</p><p>示例1:**</p><blockquote><p>输入: 4<br>输出: [<br> [“.Q..”,  // 解法 1<br>  “…Q”,<br>  “Q…”,<br>  “..Q.”],</p><p> [“..Q.”,  // 解法 2<br>  “Q…”,<br>  “…Q”,<br>  “.Q..”]<br>]<br>解释: 4 皇后问题存在两个不同的解法。</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a><strong>思路</strong></h3><p>在理解了八皇后问题之后，我们不难发现，每行放置一个且仅一个皇后。每放置一个皇后，则棋盘上与该皇后在同列和斜线上（与皇后位置行差和列差的绝对值相等）的位置无法再放置皇后。基于此，我们可以遍历每一行所有的列，如果该列可以放置，则标记（这个标记我们可以用一位数组来表示，索引代表行，值代表该行皇后放置的列），然后放置下一行的皇后。可见子问题是重复的，我们可以用回溯的方法来实现。同时不难发现，当n&lt;4且不等于1时，问题是无解的。</p><h3 id="参考实现"><a href="#参考实现" class="headerlink" title="参考实现"></a><strong>参考实现</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; res= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; solveNQueens(<span class="keyword">int</span> n) &#123;</span><br><span class="line">        res.clear();</span><br><span class="line">        List&lt;String&gt; sol=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">2</span>||n==<span class="number">3</span>)&#123;<span class="keyword">return</span> res;&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">1</span>)&#123;sol.add(<span class="string">"Q"</span>);res.add(sol);<span class="keyword">return</span> res;&#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            getsol(n,<span class="number">0</span>,tmp);</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getsol</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> row, List&lt;Integer&gt; tmp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n==row)&#123;</span><br><span class="line">            List&lt;String&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Integer i :</span><br><span class="line">                    tmp) &#123;</span><br><span class="line">                String string=<span class="string">""</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j==i)&#123;</span><br><span class="line">                        string+=<span class="string">"Q"</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        string+=<span class="string">"."</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                path.add(string);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(path);</span><br><span class="line">        &#125;</span><br><span class="line">        A:<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!tmp.contains(i))&#123;<span class="comment">//如果该列没有冲突</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; row; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span>(row-j==Math.abs(i-tmp.get(j)))&#123;</span><br><span class="line">                        <span class="keyword">continue</span> A;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp.add(i);</span><br><span class="line">                getsol(n, row + <span class="number">1</span>, tmp);</span><br><span class="line">                tmp.remove(tmp.size() - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;题目：51-N皇后问题&quot;&gt;&lt;a href=&quot;#题目：51-N皇后问题&quot; class=&quot;headerlink&quot; title=&quot;题目：51-N皇后问题&quot;&gt;&lt;/a&gt;题目：&lt;a href=&quot;https://leetcode-cn.com/problems/n-queens
      
    
    </summary>
    
      <category term="学习" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法与数据结构" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法题目" scheme="http://liutaiyu.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"/>
    
      <category term="Hard" scheme="http://liutaiyu.cn/tags/Hard/"/>
    
  </entry>
  
  <entry>
    <title>Python笔记</title>
    <link href="http://liutaiyu.cn/2019/04/21/Python%E7%AC%94%E8%AE%B0/"/>
    <id>http://liutaiyu.cn/2019/04/21/Python笔记/</id>
    <published>2019-04-21T03:04:32.000Z</published>
    <updated>2019-04-21T03:11:16.158Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Python多元赋值"><a href="#Python多元赋值" class="headerlink" title="Python多元赋值"></a>Python多元赋值</h3><p>python中有一种赋值机制即多元赋值，采用这种方式赋值时，等号两边的对象都是元组并且元组的小括号是可选的。通常形式为：</p><blockquote><p>x, y, z = 1, 2, ‘a string’     </p><p>等同于 (x, y, z) = (1, 2, ‘a string’) </p></blockquote><p>这种赋值类型最经常用到的环境是变量交换，形如</p><blockquote><p>x, y = y, x</p></blockquote><p>这种交换方式无需中间变量即可交换两个变量的值。那么具体实现机制是怎样的呢？</p><p>运行时，首先构造一个元组(y, x)，然后构造另一个元组(x, y)，接着用元组(y, x)赋值给(x, y)，元组赋值过程从左到右，依次进行。假如x=1,y=2，先令x=y,此时x=2,然后令y=x,y应该等于2？那么就不能实现变量交换了？对于这个问题，应该从元组的特性说起。</p><blockquote><p>x, y, z = 1, 2, ‘a string’<br>tuple = (x, y, z)</p></blockquote><p>变量名x, y, z都是引用，内存开辟除了三个空间分别存储1, 2, ‘a string’，三个变量分别指向这三块地址。由这三个变量构造的元组tuple，它有三个元素，这三个元素并不是x,y,z这三个变量，而是这三个变量所指向的地址空间里的内容。如果此时再另x=4,此时在地址空间会另开辟出一块空间存储4，x进而指向这块空间，而元组内的三个值仍保持不变。所以对于 x, y = y, x 来说，首先由y,x所构成的元组(y,x)其实应该表示为(2,1),那么再从左到右赋值，就可以交换变量的值了。</p><p>对于此，LeetCode中有一道<a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">链表反转</a>的题目，借助多元赋值可以使代码非常简洁。给出实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(self, head: ListNode)</span> -&gt; ListNode:</span></span><br><span class="line">        p, rev = head, <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            rev, rev.next, p = p, rev, p.next</span><br><span class="line">        <span class="keyword">return</span> rev</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Python多元赋值&quot;&gt;&lt;a href=&quot;#Python多元赋值&quot; class=&quot;headerlink&quot; title=&quot;Python多元赋值&quot;&gt;&lt;/a&gt;Python多元赋值&lt;/h3&gt;&lt;p&gt;python中有一种赋值机制即多元赋值，采用这种方式赋值时，等号两边的对象都
      
    
    </summary>
    
      <category term="学习" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="计算机语言" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="Python" scheme="http://liutaiyu.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>ROS常用命令记录</title>
    <link href="http://liutaiyu.cn/2019/04/17/ROS%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95/"/>
    <id>http://liutaiyu.cn/2019/04/17/ROS常用命令记录/</id>
    <published>2019-04-17T08:02:41.000Z</published>
    <updated>2019-04-20T06:47:45.496Z</updated>
    
    <content type="html"><![CDATA[<h2 id="主机和相关组件：roscore"><a href="#主机和相关组件：roscore" class="headerlink" title="主机和相关组件：roscore"></a>主机和相关组件：roscore</h2><p><strong>roscore</strong>是一个<strong>向节点提供连接信息</strong>，以便节点间可以相互传递信息的<strong>服务程序</strong>。同时，它也提供了一个被节点广泛用于程序配置的<strong>参数服务器</strong>（参数服务器允许节点存储和获取任意数据结构，有命令rosparam用于交互）。它主要作用在于：</p><ul><li>每个节点都在启动时连接到roscore并<strong>注册</strong>该节点发布和订阅的消息</li><li>roscore向新节点提供与其他<strong>发布并订阅相同消息主题的节点</strong>建立<strong>点对点连接</strong>的必要信息</li><li><strong>每一个ROS都需要roscore</strong>，否则节点之间无法互相找到</li></ul><p>当ROS启动时，我们会首先执行roscore，该进程含有一个名为ROS_MASTER_URI的环境变量，这是一个格式为<a href="http://hostname:11311/的字符串，表示roscore有一个实例可以通过这个URI在网络中进行访问。而roscore实际上则启动了三个工具：" target="_blank" rel="noopener">http://hostname:11311/的字符串，表示roscore有一个实例可以通过这个URI在网络中进行访问。而roscore实际上则启动了三个工具：</a></p><ol><li>主机，处理系统中的各类名称管理。维护一个关于节点名称和网络地址的映射列表。</li><li>参数服务器，管理系统中各参数设置的键值对数据</li><li>rosout节点，收集其他各个节点的调试信息</li></ol><p>已知roscore的网络位置后，节点在roscore完成注册（提供节点的网络地址）并请求roscore通过命名找到其他节点和数据流。</p><ul><li>节点告诉roscore该节点发布和订阅的消息信息</li><li>roscore向节点提供相关消息的生产者和使用者的地址</li></ul><p><img src="https://charlyhuangrostutorial.files.wordpress.com/2016/09/a.png?w=599&amp;h=340" alt="roscore与其他节点短暂连接"></p><p>上图中的节点周期性的调用roscore来确保相互之间能被找到，而交换点到点消息是两个节点直接完成的。</p><h2 id="参数管理：rosparam"><a href="#参数管理：rosparam" class="headerlink" title="参数管理：rosparam"></a>参数管理：rosparam</h2><h2 id="文件系统："><a href="#文件系统：" class="headerlink" title="文件系统："></a>文件系统：</h2><h3 id="roscd"><a href="#roscd" class="headerlink" title="roscd"></a>roscd</h3><h3 id="rospack"><a href="#rospack" class="headerlink" title="rospack"></a>rospack</h3><blockquote><p>rospack find <package> 查找包的路径</package></p></blockquote><h2 id="节点启动"><a href="#节点启动" class="headerlink" title="节点启动"></a>节点启动</h2><h3 id="单节点启动：rosrun"><a href="#单节点启动：rosrun" class="headerlink" title="单节点启动：rosrun"></a>单节点启动：rosrun</h3><h3 id="多节点启动：roslaunch"><a href="#多节点启动：roslaunch" class="headerlink" title="多节点启动：roslaunch"></a>多节点启动：roslaunch</h3><h2 id="多节点系统测试：rostest"><a href="#多节点系统测试：rostest" class="headerlink" title="多节点系统测试：rostest"></a>多节点系统测试：rostest</h2><h2 id="系统监控"><a href="#系统监控" class="headerlink" title="系统监控"></a>系统监控</h2><h3 id="节点监控：rosnode"><a href="#节点监控：rosnode" class="headerlink" title="节点监控：rosnode"></a>节点监控：rosnode</h3><h3 id="话题监控：rostopic"><a href="#话题监控：rostopic" class="headerlink" title="话题监控：rostopic"></a>话题监控：rostopic</h3><h3 id="服务监控：rosservice"><a href="#服务监控：rosservice" class="headerlink" title="服务监控：rosservice"></a>服务监控：rosservice</h3><h3 id="服务请求和响应类型：rossrv"><a href="#服务请求和响应类型：rossrv" class="headerlink" title="服务请求和响应类型：rossrv"></a>服务请求和响应类型：rossrv</h3><h2 id="日志消息"><a href="#日志消息" class="headerlink" title="日志消息"></a>日志消息</h2><h3 id="rosout和-rosout-agg"><a href="#rosout和-rosout-agg" class="headerlink" title="/rosout和/rosout_agg"></a>/rosout和/rosout_agg</h3><h2 id="数据记录和分析"><a href="#数据记录和分析" class="headerlink" title="数据记录和分析"></a>数据记录和分析</h2><h3 id="rosbag"><a href="#rosbag" class="headerlink" title="rosbag"></a>rosbag</h3><h3 id="rostopic-echo-b"><a href="#rostopic-echo-b" class="headerlink" title="rostopic echo -b"></a>rostopic echo -b</h3><h2 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h2><h3 id="日志消息：rqt-console"><a href="#日志消息：rqt-console" class="headerlink" title="日志消息：rqt_console"></a>日志消息：rqt_console</h3><h3 id="节点、话题和连接：rqt-graph"><a href="#节点、话题和连接：rqt-graph" class="headerlink" title="节点、话题和连接：rqt_graph"></a>节点、话题和连接：rqt_graph</h3><h3 id="数据图表：rqt-plot"><a href="#数据图表：rqt-plot" class="headerlink" title="数据图表：rqt_plot"></a>数据图表：rqt_plot</h3><h3 id="话题数据可视化：rqt-bag"><a href="#话题数据可视化：rqt-bag" class="headerlink" title="话题数据可视化：rqt_bag"></a>话题数据可视化：rqt_bag</h3><h3 id="仿真工具：rviz"><a href="#仿真工具：rviz" class="headerlink" title="仿真工具：rviz"></a>仿真工具：rviz</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;主机和相关组件：roscore&quot;&gt;&lt;a href=&quot;#主机和相关组件：roscore&quot; class=&quot;headerlink&quot; title=&quot;主机和相关组件：roscore&quot;&gt;&lt;/a&gt;主机和相关组件：roscore&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;roscore&lt;/s
      
    
    </summary>
    
      <category term="学习" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="ROS" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/ROS/"/>
    
    
      <category term="ROS" scheme="http://liutaiyu.cn/tags/ROS/"/>
    
      <category term="Linux" scheme="http://liutaiyu.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>决策树基础</title>
    <link href="http://liutaiyu.cn/2019/04/15/%E5%86%B3%E7%AD%96%E6%A0%91%E5%9F%BA%E7%A1%80/"/>
    <id>http://liutaiyu.cn/2019/04/15/决策树基础/</id>
    <published>2019-04-15T03:04:25.000Z</published>
    <updated>2019-04-15T10:09:00.810Z</updated>
    
    <content type="html"><![CDATA[<h3 id="决策树（Decision-Tree）"><a href="#决策树（Decision-Tree）" class="headerlink" title="决策树（Decision Tree）"></a>决策树（Decision Tree）</h3><p>决策树是一种基本的分类和回归的方法，它是一种树形结构。其每个非叶节点表示一个<strong>特征属性</strong>上的测试，每个分支代表这个特征属性在其取值范围内的某一输出，而每个叶节点存放一个<strong>类别</strong>。</p><p>决策树进行<strong>决策的过程</strong>就是从根节点开始，测试待分类项中相应的特征属性，并按照其值选择输出分支，直到到达叶子节点，将叶子节点存放的类别作为决策结果。</p><p>决策树学习本质上是从训练数据集中归纳出一组分类规则。通常用损失函数表示这一目标，损失函数通常是正则化的极大似然函数，<strong>学习的策略是以损失函数为目标函数的最小化。</strong>学习的算法一般是启发式方法，近似求解最优值。学习算法是一个递归选择最优特征的过程。为了避免最后学习到的决策树发生过拟合现象，我们通常使用验证集来对学习到的决策树进行剪枝，使其有更好的泛化能力。</p><p><img src="https://o9wdag.ch.files.1drv.com/y4mOs4BhnCR_drkQjLvsWHyugFVX8gfiPGrCOVK2PuQUD8FH9dmzbiEL3JYB4Z0GtJfTEte5u_UDkWaXC5gsV58z_NCdSWe5tSh8GljXMqqHLYNCU-TxUTuMJ02fZDhWIdDlBAn87AKmD4cU3SZfm5XdjetIDVSm-o0wNzvFNVL5UjK72EHrvZ2sWlOO4aDp_LSh6c5QYiG9MNm5RbbodT9fg?width=706&amp;height=462&amp;cropmode=none" alt="决策树结构"></p><p><strong>决策树的结构有以下特点：</strong></p><ul><li>结点和有向边组成</li><li>结点有内部结点和叶结点俩种类型</li><li>内部结点表示一个特征，叶节点表示一个类，边表示该特征下可能的输出值</li></ul><p><strong>决策树学习的步骤通常包括：</strong></p><ul><li>特征选择</li><li>决策树的生成</li><li>决策树的剪枝</li></ul><p>下面从决策树学习的三个步骤介绍决策树模型的原理：</p><h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><p>特征选择的目的在于选取对训练数据能够分类的特征，常用的特征选择算法有ID.3、C4.5和基尼系数，相关的公式如下：</p><h4 id="ID-3"><a href="#ID-3" class="headerlink" title="ID.3"></a>ID.3</h4><p>样本集合D对特征A的信息增益</p><script type="math/tex; mode=display">g(D,A)=H(D)-H(D|A)\\H(D)=-\sum_{k=1}^{K}\frac{\left | C_{k} \right |}{\left | D \right |}\log_{2}\frac{\left | C_{k} \right |}{\left | D \right |}\\H(D|A)=-\sum_{i=1}^{n}\frac{\left | D_{i} \right |}{\left | D \right |}H(D_{i})</script><p>其中$H(D)$是数据集D的熵，<script type="math/tex">H(D_i)</script>是数据集<script type="math/tex">D_i</script>的熵，$H(D|A)$是数据集D对特征A的条件熵。<script type="math/tex">D_i</script>是D中特征A取第i个值的样本子集，<script type="math/tex">C_k</script>是D中属于第k类的样本子集。n是特征A取值的个数，K是类的个数。</p><h4 id="C4-5"><a href="#C4-5" class="headerlink" title="C4.5"></a>C4.5</h4><script type="math/tex; mode=display">g_{R}(D,A)=\frac{g(D,A)}{H_{A}(D)}</script><p>其中，$g(D,A)$是信息增益，$H_{A}(D)$是D关于特征A的值的熵。</p><h4 id="CART（分类问题）"><a href="#CART（分类问题）" class="headerlink" title="CART（分类问题）"></a>CART（分类问题）</h4><script type="math/tex; mode=display">Gini(D)=1-\sum_{k=1}^{K}\left ( \frac{\left | C_{k} \right |}{\left | D \right |} \right )^2</script><p>特征A条件下集合D的基尼系数：</p><script type="math/tex; mode=display">Gini(D,A)=\frac{\left | D_{1} \right |}{\left | D \right |}Gini(D_{1})+\frac{\left | D_{2} \right |}{\left | D \right |}Gini(D_{2})</script><h3 id="决策树的生成"><a href="#决策树的生成" class="headerlink" title="决策树的生成"></a>决策树的生成</h3><p>通常使用上述特征选择的方法，从根节点开始，递归的生成决策树。这里主要讲一下CART回归树的生成，CART对<strong>回归树用平方误差最小化准则，对分类树用基尼系数最小化准则</strong>，进行特征选择，生成树。</p><h4 id="回归树"><a href="#回归树" class="headerlink" title="回归树"></a>回归树</h4><p>假设X,Y为输入和输出，Y为连续变量。假设我们将输入空间划分为M个单元$R_1…R_M​$，并且每个单元$R_m​$上有一个固定的输出值${c_m}​$，模型可以表示为：</p><script type="math/tex; mode=display">f(x)=\sum_{m=1}^{M}c_{m}I(x\in{R_{m}})</script><p>我们可以用平方误差<script type="math/tex">\sum_{x_{i}\in{R_{m}}}{(y_{i}-f(x_{i}))^2}​</script>来表示回归树的训练误差，易知单元<script type="math/tex">{R_m}​</script>上的<script type="math/tex">{c_m}​</script>的最优值是单元上所有输入实例对应的输出值的均值：</p><script type="math/tex; mode=display">\hat c_m=ave(y_i|x_i \in{R_m})</script><p>对于空间的划分，我们选择第j个特征$x^{(j)}$和它的取值s，并定义两个区域：</p><script type="math/tex; mode=display">R_1(j,s)=\{x|x^{(j)}\leq s\}\hspace{3em}\hat R_2(j,s)=\{x|x^{(j)}> s\}</script><p>然后求解：</p><script type="math/tex; mode=display">\min_{j,s}\left [ \min_{c_1}\sum_{x_{i}\in{R_{1}(j,s)}}(y_{i}-c_1)^2 +\min_{c_2}\sum_{x_{i}\in{R_{2}(j,s)}}(y_{i}-c_2)^2 \right ]</script><p>对于固定的输入变量j，可以找到s.</p><script type="math/tex; mode=display">\hat c_m=\frac{1}{N_m}\sum_{x_i \in{R_{m}(j,s)}}y_i\hspace{1em}(x\in R_m,m=1,2)</script><p>然后遍历j，找到最优的（j，s）对。然后依据此对空间做一次划分，重复上述过程。这样生成的树我们通常称为最小二乘回归树。<strong>每一次划分后，下一次拟合的是残差。</strong></p><h3 id="决策树的剪枝"><a href="#决策树的剪枝" class="headerlink" title="决策树的剪枝"></a>决策树的剪枝</h3><p>决策树的剪枝<strong>通过极小化决策树整体的Loss来实现</strong>，假设决策树T的叶节点个数为|T|，t是树T的叶节点，该叶节点有<script type="math/tex">N_t</script>个样本点，其中k类的样本点有<script type="math/tex">N_{tk}</script>个，<script type="math/tex">k=1,2,...,K</script>，<script type="math/tex">H_{t}(T)</script>为叶节点t上的经验熵，<script type="math/tex">\alpha \geq 0</script>为参数，则决策树学习的损失函数定义为：其中经验熵为：<script type="math/tex">H_{t}(T)=-\sum_{k=1}^{K}\frac{N_{tk}}{N_{t}}\log \frac{N_{tk}}{N_{t}}</script></p><script type="math/tex; mode=display">\begin{align}C_{\alpha}(T)&=\sum_{t=1}^{|T|}N_{t}H_{t}(T)+\alpha|T|\\&=-\sum_{t=1}^{|T|}\sum_{k=1}^{K}N_{tk}\log \frac{N_{tk}}{N_{t}}+\alpha|T|\\&=C(T)+\alpha|T|\end{align}</script><p>上式中C(T)表示模型对训练数据的预测误差，即模型和训练数据的拟合程度，|T|表示模型的复杂度。剪枝就是当α确定时，选择损失函数最小的模型，即损失函数最小的子树。</p><blockquote><p>算法：</p><p>输入：生成树T，参数α</p><p>输出：修剪后的子树$T_{\alpha}​$</p><ol><li>计算每个节点的经验熵</li><li>递归的从树的叶节点向上回缩，<strong>如果回缩到父节点前后的损失函数值不增加，那么进行剪枝，将父节点变为新的叶节点</strong></li><li>返回2，直至不能继续，得到损失函数最小的子树$T_{\alpha}$</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;决策树（Decision-Tree）&quot;&gt;&lt;a href=&quot;#决策树（Decision-Tree）&quot; class=&quot;headerlink&quot; title=&quot;决策树（Decision Tree）&quot;&gt;&lt;/a&gt;决策树（Decision Tree）&lt;/h3&gt;&lt;p&gt;决策树是一种
      
    
    </summary>
    
      <category term="学习" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="机器学习" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="监督学习" scheme="http://liutaiyu.cn/tags/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法模型" scheme="http://liutaiyu.cn/tags/%E7%AE%97%E6%B3%95%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Hexo中使用Latex公式</title>
    <link href="http://liutaiyu.cn/2019/04/13/Hexo%E4%B8%AD%E4%BD%BF%E7%94%A8Latex%E5%85%AC%E5%BC%8F/"/>
    <id>http://liutaiyu.cn/2019/04/13/Hexo中使用Latex公式/</id>
    <published>2019-04-13T11:47:08.000Z</published>
    <updated>2019-04-15T08:29:16.483Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>公式插入格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$数学公式$ 行内 不独占一行</span><br><span class="line">$$数学公式$$ 行间 独占一行</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$f(x)=ax+b$  #行内显示</span><br><span class="line">$$</span><br><span class="line">f(x)=ax+b    #行间显示</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>显示效果为：$f(x)=ax+b​$</p><p>行间使用则为：</p><script type="math/tex; mode=display">f(x)=ax+b</script><h3 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h3><h4 id="上标与下标"><a href="#上标与下标" class="headerlink" title="上标与下标"></a>上标与下标</h4><p>使用 ^ 表示上标，使用 _ 表示下标，如果上下标的内容多于一个字符，可以使用大括号括起来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$f(x) = a_1x^n + a_2x^&#123;n-1&#125; + a_3x^&#123;n-2&#125;$$</span><br></pre></td></tr></table></figure><p>显示效果为：</p><script type="math/tex; mode=display">f(x) = a_1x^n + a_2x^{n-1} + a_3x^{n-2}</script><p>如果左右两边都有上下标可以使用 \sideset 语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\sideset&#123;^n_k&#125;&#123;^x_y&#125;a$$</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\sideset{^n_k}{^x_y}a</script><h4 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h4><p>在 markdown 语法中，\, $, {, }, _都是有特殊含义的，所以需要加\转义。小括号与方括号可以使用原始的() [] 大括号需要转义\也可以使用\lbrace和 \rbrace</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\&#123;x*y\&#125;</span><br><span class="line">\lbrace x*y \rbrace</span><br></pre></td></tr></table></figure><p>显示效果为：$\lbrace x*y \rbrace$</p><p>原始符号不会随着公式大小自动缩放，需要使用 \left 和 \right 来实现自动缩放：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\left \lbrace \sum_&#123;i=0&#125;^n i^3 = \frac&#123;(n^2+n)(n+6)&#125;&#123;9&#125; \right \rbrace$$</span><br></pre></td></tr></table></figure><p>效果(加上了\left 和 \right):$\left \lbrace \sum_{i=0}^n i^3 = \frac{(n^2+n)(n+6)}{9} \right \rbrace$</p><p>没加的效果：$ \lbrace \sum_{i=0}^n i^3 = \frac{(n^2+n)(n+6)}{9} \rbrace$</p><h4 id="分数与开方"><a href="#分数与开方" class="headerlink" title="分数与开方"></a>分数与开方</h4><p>可以使用\frac 或者 \over 实现分数的显示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$\frac xy$</span><br><span class="line">$ x+3 \over y+5 $</span><br></pre></td></tr></table></figure><p>分别显示为：</p><p>$\frac xy$       $ x+3 \over y+5 $</p><p>开方使用\sqrt:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ \sqrt&#123;x^5&#125; $</span><br><span class="line">$ \sqrt[3]&#123;\frac xy&#125; $</span><br></pre></td></tr></table></figure><p>显示为：$ \sqrt{x^5} $     $ \sqrt[3]{\frac xy} $</p><h4 id="求和与积分"><a href="#求和与积分" class="headerlink" title="求和与积分"></a>求和与积分</h4><p>求和使用\sum,可加上下标，积分使用\int可加上下限，双重积分用\iint:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ \sum_&#123;i=0&#125;^n $</span><br><span class="line">$ \int_a ^ b $</span><br><span class="line">$ \iint_1 ^ \infty $</span><br></pre></td></tr></table></figure><p>分别显示：$ \sum_{i=0}^n $   $ \int_a^b $  $ \iint_1^\infty $</p><h4 id="极限"><a href="#极限" class="headerlink" title="极限"></a>极限</h4><p>极限使用\lim:       $ \lim_{x \to 0} $</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ \lim_&#123;x \to 0&#125; $</span><br></pre></td></tr></table></figure><h4 id="表格与矩阵"><a href="#表格与矩阵" class="headerlink" title="表格与矩阵"></a>表格与矩阵</h4><p>表格样式lcr表示居中，|加入一条竖线，\hline表示行间横线，列之间用&amp;分隔，行之间用\分隔：</p><script type="math/tex; mode=display">\begin{array}{c|lcr}n & \text{Left} & \text{Center} & \text{Right} \\\\\hline1 & 1.97 & 5 & 12 \\\\2 & -11 & 19 & -80 \\\\3 & 70 & 209 & 1+i \\\\\end{array}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$\begin&#123;array&#125;&#123;c|lcr&#125;</span><br><span class="line">n &amp; \text&#123;Left&#125; &amp; \text&#123;Center&#125; &amp; \text&#123;Right&#125; \\\\</span><br><span class="line">\hline</span><br><span class="line">1 &amp; 1.97 &amp; 5 &amp; 12 \\\\</span><br><span class="line">2 &amp; -11 &amp; 19 &amp; -80 \\\\</span><br><span class="line">3 &amp; 70 &amp; 209 &amp; 1+i \\\\</span><br><span class="line">\end&#123;array&#125;$$</span><br></pre></td></tr></table></figure><p>矩阵:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$$\left[</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">V_A \\\\</span><br><span class="line">V_B \\\\</span><br><span class="line">V_C \\\\</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">\right] =</span><br><span class="line">\left[</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">1 &amp; 0 &amp; L \\\\</span><br><span class="line">-cosψ &amp; sinψ &amp; L \\\\</span><br><span class="line">-cosψ &amp; -sinψ &amp; L</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">\right]</span><br><span class="line">\left[</span><br><span class="line">\begin&#123;matrix&#125;</span><br><span class="line">V_x \\\\</span><br><span class="line">V_y \\\\</span><br><span class="line">W \\\\</span><br><span class="line">\end&#123;matrix&#125;</span><br><span class="line">\right] $$</span><br></pre></td></tr></table></figure><p>显示效果：</p><script type="math/tex; mode=display">\left[\begin{matrix}V_A \\\\V_B \\\\V_C \\\\\end{matrix}\right] =\left[\begin{matrix}1 & 0 & L \\\\-cosψ & sinψ & L \\\\-cosψ & -sinψ & L\end{matrix}\right]\left[\begin{matrix}V_x \\\\V_y \\\\W \\\\\end{matrix}\right]</script><h4 id="换行问题（换行，等号对齐）"><a href="#换行问题（换行，等号对齐）" class="headerlink" title="换行问题（换行，等号对齐）"></a>换行问题（换行，等号对齐）</h4><p>公示太长需要换行的问题，并且是连等公示，每个等号在还行之后都需要对齐。 可以使用：</p><p>其中aligned就是用来公式对齐的，在中间公式中，\\ 表示换行， &amp; 表示对齐。在公式中等号之前加&amp;，等号介绍要换行的地方加\\就可以了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;equation&#125;</span><br><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">......</span><br><span class="line">\end&#123;aligned&#125;</span><br><span class="line">\end&#123;equation&#125;</span><br><span class="line">例如：</span><br><span class="line">\begin&#123;equation*&#125;%加*表示不对公式编号</span><br><span class="line">\begin&#123;split&#125;</span><br><span class="line">PMV =&amp;[0.303*exp(-0.036M)+0.0275]*\&#123;M-W-3.05*[5.733-\\</span><br><span class="line">&amp;0.007(M-W)-P_a]-0.42*(M-W-58.2)-0.0173M*\\</span><br><span class="line">&amp;(5.867-P_a)-0.0014M*(34-t_a)-3.96*10^-8*f_cl*[(t_cl+\\</span><br><span class="line">&amp;273)^4-(t_r+273)^4]-f_cl*h_c*(t_cl-t_a)\&#125;</span><br><span class="line">\end&#123;split&#125;</span><br><span class="line">\end&#123;equation*&#125;</span><br></pre></td></tr></table></figure><script type="math/tex; mode=display">\begin{equation*}%加*表示不对公式编号\begin{split}PMV =&[0.303*exp(-0.036M)+0.0275]*\{M-W-3.05*[5.733-\\&0.007(M-W)-P_a]-0.42*(M-W-58.2)-0.0173M*\\&(5.867-P_a)-0.0014M*(34-t_a)-3.96*10^-8*f_cl*[(t_cl+\\&273)^4-(t_r+273)^4]-f_cl*h_c*(t_cl-t_a)\}\end{split}\end{equation*}</script><p>参考：<a href="http://stevenshi.me/2017/06/26/hexo-insert-formula/" target="_blank" rel="noopener">http://stevenshi.me/2017/06/26/hexo-insert-formula/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;使用&quot;&gt;&lt;a href=&quot;#使用&quot; class=&quot;headerlink&quot; title=&quot;使用&quot;&gt;&lt;/a&gt;使用&lt;/h3&gt;&lt;p&gt;公式插入格式：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
      
    
    </summary>
    
      <category term="工作" scheme="http://liutaiyu.cn/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="博客" scheme="http://liutaiyu.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer题集笔记</title>
    <link href="http://liutaiyu.cn/2019/04/13/%E5%89%91%E6%8C%87offer%E9%A2%98%E9%9B%86/"/>
    <id>http://liutaiyu.cn/2019/04/13/剑指offer题集/</id>
    <published>2019-04-13T03:25:30.000Z</published>
    <updated>2019-04-24T04:05:21.699Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目12：矩阵中的路径"><a href="#题目12：矩阵中的路径" class="headerlink" title="题目12：矩阵中的路径"></a>题目12：矩阵中的路径</h3><ul><li><strong>题目描述</strong></li></ul><p>请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。</p><ul><li><strong>分析</strong></li></ul><p>该类问题可以用<a href="https://baike.baidu.com/item/%E5%9B%9E%E6%BA%AF%E6%B3%95" target="_blank" rel="noopener">回溯法</a>来求解，回溯法非常适合由多个步骤组成的问题，并且每个步骤都有多个选项。当我们在某一步选择了其中一个选项时，我们进入下一步，然后又面临新的选项。重复直至到达最终的状态。</p><p>该题过程主要如下：</p><p>遍历矩阵中的所有节点（因为题目允许从任何一个格子开始），对于其中一个节点作为起始节点，然后向四周（符合回溯的条件）寻找下一个和字符串匹配的节点，如果有，那么继续向后寻找路径，如果没有，则遍历下一个节点作为起始节点。直至遍历完所有节点。</p><p>过程中我们需要一个标志位来标记节点是否已为路径上的节点，和一个整数保存路径的长度。要注意的是如果该节点四周没有可以继续的路径选项，那么，需要对当前节点进行复位操作（路径长度-1，取消路径节点的标记）。</p><ul><li><strong>参考实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPath</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">char</span>[] str)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix==<span class="keyword">null</span>||str==<span class="keyword">null</span>||rows&lt;<span class="number">1</span>||cols&lt;<span class="number">1</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] visit=<span class="keyword">new</span> <span class="keyword">boolean</span>[rows*cols];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rows*cols;i++)</span><br><span class="line">            visit[i]=<span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> pathlen=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> row=<span class="number">0</span>;row&lt;rows;row++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> col=<span class="number">0</span>;col&lt;cols;col++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(has(matrix,rows,cols,row,col,str,visit,pathlen))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">has</span><span class="params">(<span class="keyword">char</span>[] matrix, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols,<span class="keyword">int</span> row,<span class="keyword">int</span> col, <span class="keyword">char</span>[] str,<span class="keyword">boolean</span>[]visit,<span class="keyword">int</span> pathlen)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pathlen==str.length)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">boolean</span> haspath=<span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">if</span>(row&lt;rows&amp;&amp;col&lt;cols&amp;&amp;row&gt;=<span class="number">0</span>&amp;&amp;col&gt;=<span class="number">0</span>&amp;&amp;matrix[row*cols+col]==str[pathlen]&amp;&amp;!visit[row*cols+col])&#123;</span><br><span class="line">            pathlen++;</span><br><span class="line">            visit[row*cols+col]=<span class="keyword">true</span>;</span><br><span class="line">            haspath = has(matrix,rows,cols,row-<span class="number">1</span>,col,str,visit,pathlen)</span><br><span class="line">                    ||has(matrix,rows,cols,row,col-<span class="number">1</span>,str,visit,pathlen)</span><br><span class="line">                    ||has(matrix,rows,cols,row,col+<span class="number">1</span>,str,visit,pathlen)</span><br><span class="line">                    ||has(matrix,rows,cols,row+<span class="number">1</span>,col,str,visit,pathlen);</span><br><span class="line">            <span class="keyword">if</span>(!haspath)&#123;</span><br><span class="line">                pathlen--;</span><br><span class="line">                visit[row*cols+col]=<span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> haspath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="题目13：机器人的运动范围"><a href="#题目13：机器人的运动范围" class="headerlink" title="题目13：机器人的运动范围"></a>题目13：机器人的运动范围</h3><ul><li><strong>题目描述</strong></li></ul><p>地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？</p><ul><li><strong>分析</strong></li></ul><p>回溯法求解，该题过程主要如下：</p><p>用count表示机器人能到达的格子的个数，机器人一开始从（0,0）开始移动，当它准备进入（i，j）时，首先检查是否能到达，如果能到达，count+1。再判断（i，j）周围相邻的格子（需要注意边界上的格子没有4个相邻格子）是否能够到达。使用一个数组来标记格子是否已达，避免重复累加。同时，定义函数返回某一格是否可达，这个函数主要是判断格子是否满足相应的约束条件。</p><ul><li><strong>参考实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(threshold&lt;<span class="number">0</span>||rows&lt;=<span class="number">0</span>||cols&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] visit = <span class="keyword">new</span> <span class="keyword">boolean</span>[rows*cols];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;rows*cols;i++)&#123;</span><br><span class="line">            visit[i]=<span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> help(threshold,rows,cols,<span class="number">0</span>,<span class="number">0</span>,visit);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span> threshold,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">boolean</span>[]visit)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(check(threshold,rows,cols,row,col,visit))&#123;</span><br><span class="line">            visit[row*cols+col]=<span class="keyword">true</span>;</span><br><span class="line">            count=<span class="number">1</span>+help(threshold,rows,cols,row-<span class="number">1</span>,col,visit)</span><br><span class="line">                +help(threshold,rows,cols,row,col-<span class="number">1</span>,visit)</span><br><span class="line">                +help(threshold,rows,cols,row+<span class="number">1</span>,col,visit)</span><br><span class="line">                +help(threshold,rows,cols,row,col+<span class="number">1</span>,visit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> threshold,<span class="keyword">int</span> rows,<span class="keyword">int</span> cols,<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">boolean</span>[]visit)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(row&gt;=<span class="number">0</span>&amp;&amp;row&lt;rows&amp;&amp;col&gt;=<span class="number">0</span>&amp;&amp;col&lt;cols&amp;&amp;getNum(row)+getNum(col)&lt;=threshold&amp;&amp;!visit[row*cols+col])<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            sum+=num%<span class="number">10</span>;</span><br><span class="line">            num/=<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="题目16：数值的整数次方"><a href="#题目16：数值的整数次方" class="headerlink" title="题目16：数值的整数次方"></a>题目16：数值的整数次方</h3><ul><li><strong>题目描述</strong></li></ul><p>给定一个double类型的浮点数base和int类型的整数exponent，求base的exponent次方。</p><ul><li><strong>分析</strong></li></ul><p>此题可以使用公式：</p><script type="math/tex; mode=display">{a^n}=\left\{\begin{matrix}{a^\frac{n}{2}}*{a^\frac{n}{2}},n为偶数\\{a^\frac{n-1}{2}}*{a^\frac{n-1}{2}}*a,n为奇数\end{matrix}\right.</script><p>来求解a的n次幂，目的是可以减小乘法的次数，另外需要判断当幂指数不大于0和底数为0时的边界条件。</p><ul><li><strong>参考实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> res=<span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>((exponent&amp;<span class="number">1</span>)==<span class="number">1</span>)res=base;</span><br><span class="line">        <span class="keyword">boolean</span> flag=<span class="keyword">true</span>; <span class="comment">//标识位幂指数是否为负</span></span><br><span class="line">        <span class="keyword">if</span>(exponent&lt;<span class="number">0</span>)&#123;<span class="comment">//转为正幂指数</span></span><br><span class="line">            <span class="keyword">if</span>(base==<span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            flag=<span class="keyword">false</span>;</span><br><span class="line">            exponent*=-<span class="number">1</span>;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">double</span> tmp=base*base;</span><br><span class="line">        <span class="keyword">while</span>(exponent&gt;<span class="number">1</span>)&#123;<span class="comment">//求乘法</span></span><br><span class="line">            res*=tmp;</span><br><span class="line">            tmp=res;</span><br><span class="line">            exponent = exponent&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag?res:<span class="number">1</span>/res;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="题目21：调整数组数顺序使奇数位于偶数前面"><a href="#题目21：调整数组数顺序使奇数位于偶数前面" class="headerlink" title="题目21：调整数组数顺序使奇数位于偶数前面"></a>题目21：调整数组数顺序使奇数位于偶数前面</h3><ul><li><strong>题目描述</strong></li></ul><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p><ul><li><strong>分析</strong></li></ul><p>该题和原书中的题有一点不一样，本题要求保证数组元素的稳定。书中最简单的方法是从头到尾扫描数组，碰到一个偶数，拿出来放到数组末尾，其他元素向前移动一位。没碰到一个偶数我们就要移动$O\left ( n \right )$该方法时间复杂度为$O\left ( n^{2} \right )$。书中改进的方法是设置两个指针分别指向数组两端，如果碰到奇数偶数对，那么交换。这种方法显然是不稳定的。</p><ul><li><strong>参考实现</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReorderOddEven_1</span><span class="params">(<span class="keyword">int</span> *pData, <span class="keyword">unsigned</span> <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pData == <span class="literal">nullptr</span> || length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> *pBegin = pData;</span><br><span class="line">    <span class="keyword">int</span> *pEnd = pData + length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(pBegin &lt; pEnd)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 向后移动pBegin，直到它指向偶数</span></span><br><span class="line">        <span class="keyword">while</span>(pBegin &lt; pEnd &amp;&amp; (*pBegin &amp; <span class="number">0x1</span>) != <span class="number">0</span>)</span><br><span class="line">            pBegin ++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 向前移动pEnd，直到它指向奇数</span></span><br><span class="line">        <span class="keyword">while</span>(pBegin &lt; pEnd &amp;&amp; (*pEnd &amp; <span class="number">0x1</span>) == <span class="number">0</span>)</span><br><span class="line">            pEnd --;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(pBegin &lt; pEnd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = *pBegin;</span><br><span class="line">            *pBegin = *pEnd;</span><br><span class="line">            *pEnd = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述书中的方法可以将while中对奇偶数的判断条件改成判定函数，则可以拓展代码的重用性。实现在给定的条件下，将数组划分成两部分。针对本题，考虑到稳定性，可以建一个队列，循环3次，分别将奇数、偶数打入队列，然后将队列输出修改原数组。时间复杂度是$3O\left( n\right)$，空间复杂度是$O\left(n\right)​$。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reOrderArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>||array.length==<span class="number">0</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> len = array.length;</span><br><span class="line">        Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((array[i]&amp;<span class="number">1</span>)==<span class="number">1</span>)queue.offer(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((array[i]&amp;<span class="number">1</span>)==<span class="number">0</span>)queue.offer(array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">            array[i]=queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="题目22：链表中倒数第k个结点"><a href="#题目22：链表中倒数第k个结点" class="headerlink" title="题目22：链表中倒数第k个结点"></a>题目22：链表中倒数第k个结点</h3><ul><li><strong>题目描述</strong></li></ul><p>输入一个链表，输出该链表中倒数第k个结点。</p><ul><li><strong>分析</strong></li></ul><p>该题最简单的思路是遍历两次，一次求得链表长度，第二次找到倒数第k个点。优化的办法是，设置两个指针，第一个指针遍历到第k-1个节点，第二个指针再从头开始，两个指针同时扫描直至第一个指针到达链表末尾。此时第二个指针指向的就是倒数第K个节点。</p><p>这中间有几个边界条件需要特别注意：</p><ol><li>输入链表为空</li><li>输入k为0</li><li>链表节点个数小于K</li></ol><ul><li><strong>参考实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">FindKthToTail</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>||k==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode front=head;</span><br><span class="line">        ListNode last;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(front.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                front=front.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        last=head;</span><br><span class="line">        <span class="keyword">while</span>(front.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            last=last.next;</span><br><span class="line">            front=front.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="题目24：反转链表"><a href="#题目24：反转链表" class="headerlink" title="题目24：反转链表"></a>题目24：反转链表</h3><ul><li><strong>题目描述</strong></li></ul><p>输入一个链表，反转链表后，输出新链表的表头。</p><ul><li><strong>分析</strong></li></ul><p>a-&gt;b-&gt;c-&gt;d…h-&gt;i-&gt;j-&gt;…</p><p>a&lt;-b&lt;-c&lt;-d…h&lt;-i   j-&gt;…</p><p>该问题关键在解决反转链表后的断裂怎么处理，我们用三个指针来处理。</p><ul><li><strong>参考实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode now = <span class="keyword">null</span>;     \\指向当前操作的节点</span><br><span class="line">        ListNode front = head;   \\指向下一个操作的节点</span><br><span class="line">        ListNode res=<span class="keyword">null</span>;       \\指向反转链表的尾结点</span><br><span class="line">        <span class="keyword">while</span>(front!=<span class="keyword">null</span>)&#123;      \\判断是否到达尾结点</span><br><span class="line">            now=front;           \\获得本轮操作节点</span><br><span class="line">            front=front.next;    \\front指向下一个节点，解决链表断裂</span><br><span class="line">            \\反转节点</span><br><span class="line">            now.next=res;</span><br><span class="line">            res=now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="题目25：合并两个排序的链表"><a href="#题目25：合并两个排序的链表" class="headerlink" title="题目25：合并两个排序的链表"></a>题目25：合并两个排序的链表</h3><ul><li><strong>题目描述</strong></li></ul><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><ul><li><strong>分析</strong></li></ul><p>链表合并的过程如下图所示：</p><p><img src="https://qtz5aq.ch.files.1drv.com/y4ma1HbikeYEQ_RqZxLokCR41f8eSRTJaqAI6BYlOpCxAnI6ZJRRCBurti5F9zfWZvVp8rGrjawlWw2AHN1VWft2Ld9CnLIzbZtrv30EduoGdUQjqVQfdA0jlQKdbfvIelfBZzMN9ys0az5YazAB3wKcSCXK2QQwwONxpTCOsrSixzMksQBd1iert12RyyuNT1R2AlL4G3Opv8aCxsh_IiqCg?width=2691&amp;height=2355&amp;cropmode=none" alt="链表合并过程"></p><p>每一次都是选择两个链表中较小值的节点作为合并链表的头结点，然后我们再将上一次合并链表的尾结点与本次的头结点链接起来，就可以得到合并的链表。具体实现，用递归是最简单的。时间复杂度为<script type="math/tex">O(list1.length+list2.lenght)</script></p><ul><li><strong>参考实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class ListNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    ListNode next = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    ListNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1,ListNode list2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(list1==<span class="keyword">null</span>)<span class="keyword">return</span> list2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(list2==<span class="keyword">null</span>)<span class="keyword">return</span> list1;</span><br><span class="line">        ListNode res=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(list1.val&lt;list2.val)&#123;</span><br><span class="line">            res=list1;</span><br><span class="line">            res.next=Merge(list1.next,list2);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res=list2;</span><br><span class="line">            res.next=Merge(list1,list2.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="题目26：树的子结构"><a href="#题目26：树的子结构" class="headerlink" title="题目26：树的子结构"></a>题目26：树的子结构</h3><ul><li><strong>题目描述</strong></li></ul><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><ul><li><strong>分析</strong></li></ul><p>本题实际上考察的是树的遍历和树指针的操作，同时还有遍历过程中边界条件的处理。问题可以分成两步：</p><ul><li>在A中找到与B根节点相同的节点；此步骤我们只需要遍历A树即可，我们任意选择一种树的遍历的方法即可，此处我们选择实现较为简单的递归遍历。遍历的边界条件是不能为空树；</li><li><p>判断A中该节点的子树和B是否有相同的结构；当我们能够遍历到B树的子节点的时候，代表两个子树有相同的结构。我们分别遍历左子树和右子树，当两个子树都有相同结构时，返回true，否则返回false。</p></li><li><p><strong>参考实现</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;    </span></span><br><span class="line"><span class="comment">int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">HasSubtree</span><span class="params">(TreeNode root1,TreeNode root2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> res = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1!=<span class="keyword">null</span>&amp;&amp;root2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(root1.val==root2.val)res=help(root1,root2);</span><br><span class="line">            <span class="keyword">if</span>(!res)res=HasSubtree(root1.left,root2);</span><br><span class="line">            <span class="keyword">if</span>(!res)res=HasSubtree(root1.right,root2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">help</span><span class="params">(TreeNode root1,TreeNode root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root2==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1.val!=root2.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> help(root1.left,root2.left)&amp;&amp;help(root1.right,root2.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="题目27：二叉树的镜像"><a href="#题目27：二叉树的镜像" class="headerlink" title="题目27：二叉树的镜像"></a>题目27：二叉树的镜像</h3><ul><li><strong>题目描述</strong></li></ul><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><p>输入描述：</p><blockquote><p>二叉树的镜像定义：源二叉树<br>            8<br>           /  \<br>          6   10<br>         /  \   /   \<br>        5  7 9   11<br>    镜像二叉树<br>            8<br>           /  \<br>        10   6<br>            /  \   /  \<br>          11  9 7  5</p></blockquote><ul><li><strong>分析</strong></li></ul><p>本题实际上考察的是树的遍历，问题大致过程如下：</p><p>先前序遍历树的每个节点，当节点不是叶节点的时候，就交换两个子节点。要注意的是，虽然在遍历过程中对子节点进行了交换，但是递归的调用栈的顺序为前序遍历的顺序，不会改变。可以用递归直接实现，也可以借助队列循环实现。</p><ul><li><strong>参考实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror1</span><span class="params">(TreeNode root)</span> </span>&#123;  \\递归实现</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>||root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            TreeNode tmp=root.left;</span><br><span class="line">            root.left=root.right;</span><br><span class="line">            root.right=tmp;</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)Mirror(root.left);</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)Mirror(root.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Mirror2</span><span class="params">(TreeNode root)</span> </span>&#123;\\循环实现</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode now=queue.peek();</span><br><span class="line">            <span class="keyword">if</span>(now.left!=<span class="keyword">null</span>||now.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                TreeNode tmp=now.left;</span><br><span class="line">                now.left=now.right;</span><br><span class="line">                now.right=tmp;</span><br><span class="line">                queue.poll();</span><br><span class="line">                <span class="keyword">if</span>(now.left!=<span class="keyword">null</span>)queue.offer(now.left);</span><br><span class="line">                <span class="keyword">if</span>(now.right!=<span class="keyword">null</span>)queue.offer(now.right);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="题目28：对称的二叉树"><a href="#题目28：对称的二叉树" class="headerlink" title="题目28：对称的二叉树"></a>题目28：对称的二叉树</h3><ul><li><strong>题目描述</strong></li></ul><p>请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。</p><ul><li><strong>分析</strong></li></ul><p>本题实际上考察的是树的遍历过程。树的前序、中序和后序遍历都是先访问左子树，然后再访问右子树。在本题中，我们不难发现，先访问右子树再访问左子树遍历得到的序列和原来先左后右遍历得到的序列应该相同。但是有一种特殊情况，就是树的所有节点的值相同，他们的输出序列永远相同。这个时候考虑树中空节点的情况，两种遍历方式中，遍历到某个位置的时候，两个位置要么相同，要么同时为空，否则就不对称。</p><ul><li><strong>参考实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode pRoot)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(pRoot,pRoot);\\让树分别从左子树和右子树两个方向遍历</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode p1,TreeNode p2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1==<span class="keyword">null</span>&amp;&amp;p2==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p1==<span class="keyword">null</span>||p2==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(p1.val!=p2.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isSymmetrical(p1.left,p2.right)&amp;&amp;isSymmetrical(p1.right,p2.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="题目30：包含min函数的栈"><a href="#题目30：包含min函数的栈" class="headerlink" title="题目30：包含min函数的栈"></a>题目30：包含min函数的栈</h3><ul><li><strong>题目描述</strong></li></ul><p>定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。</p><ul><li><strong>分析</strong></li></ul><p>题干中我们需要定义一个栈，并且实现得到栈中最小元素的函数，并要求时间复杂度为<script type="math/tex">O(1)</script>。常规思路就是从栈顶通过迭代器搜索栈中最小的元素，但是这样做不符合时间复杂度的要求。因为题干没有限制空间复杂度，所以我们可以建一个辅助栈，使得栈顶元素始终是栈的最小元素。当然还有一种方法是建立最小堆，但是最小堆建立的时间复杂度是<script type="math/tex">O(\log N)</script>，也不符合题干要求。</p><ul><li><strong>参考实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; min_stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> node)</span> </span>&#123;</span><br><span class="line">        stack.push(node);</span><br><span class="line">        <span class="keyword">if</span>(min_stack.isEmpty()||min_stack.peek()&gt;node)&#123;</span><br><span class="line">            min_stack.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack.isEmpty())<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(stack.peek()==min_stack.peek())min_stack.pop();</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="题目32：从上往下打印二叉树"><a href="#题目32：从上往下打印二叉树" class="headerlink" title="题目32：从上往下打印二叉树"></a>题目32：从上往下打印二叉树</h3><ul><li><strong>题目描述</strong></li></ul><p>从上往下打印出二叉树的每个节点，同层节点从左至右打印。</p><ul><li><strong>分析</strong></li></ul><p>本题实际上考察的是树的层序遍历。借住队列，每次将父节点的左节点和右节点依次送入队尾，然后从队首取出元素的序列即为层序遍历。</p><ul><li><strong>参考实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">PrintFromTopToBottom</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        Queue&lt;TreeNode&gt; queue =<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.offer(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty())&#123;</span><br><span class="line">            TreeNode now=queue.peek();</span><br><span class="line">            <span class="keyword">if</span>(now.left!=<span class="keyword">null</span>)queue.offer(now.left);</span><br><span class="line">            <span class="keyword">if</span>(now.right!=<span class="keyword">null</span>)queue.offer(now.right);</span><br><span class="line">            res.add(queue.poll().val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="题目33：二叉搜索树的后序遍历序列"><a href="#题目33：二叉搜索树的后序遍历序列" class="headerlink" title="题目33：二叉搜索树的后序遍历序列"></a>题目33：二叉搜索树的后序遍历序列</h3><ul><li><strong>题目描述</strong></li></ul><p>输入一个整数数组，判断该数组是不是某<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91" target="_blank" rel="noopener">二叉搜索树</a>的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。</p><ul><li><strong>分析</strong></li></ul><p>本题考查了二叉搜索树的结构，同时考查了数组的操作。</p><ul><li><strong>参考实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence==<span class="keyword">null</span>||sequence.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(sequence.length&lt;<span class="number">3</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> help(sequence,<span class="number">0</span>,sequence.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> front,<span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(front&gt;=last)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> target=arr[last];</span><br><span class="line">        <span class="keyword">int</span> id1=front;</span><br><span class="line">        <span class="keyword">if</span>(arr[id1]&lt;target)&#123;</span><br><span class="line">            <span class="keyword">while</span>(id1&lt;last&amp;&amp;arr[id1]&lt;target)id1++;</span><br><span class="line">            <span class="keyword">int</span> id2=id1;</span><br><span class="line">            <span class="keyword">while</span>(id2&lt;last)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[id2]&lt;target)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                id2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> help(arr,front,id1-<span class="number">1</span>)&amp;&amp;help(arr,id1,last-<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(id1&lt;last)&#123;</span><br><span class="line">                <span class="keyword">if</span>(arr[id1]&lt;target)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                id1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> help(arr,front,last-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码存在冗余，检测右子树重复了。我们可以优化一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">VerifySquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sequence==<span class="keyword">null</span>||sequence.length==<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(sequence.length&lt;<span class="number">3</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> help(sequence,<span class="number">0</span>,sequence.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">help</span><span class="params">(<span class="keyword">int</span>[] arr,<span class="keyword">int</span> front,<span class="keyword">int</span> last)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(front&gt;=last)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> i=front;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;last)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i]&gt;arr[last])<span class="keyword">break</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;last;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j]&lt;arr[last])<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> help(arr,front,i-<span class="number">1</span>)&amp;&amp;help(arr,i,last-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="题目34：二叉树中和为某一值的路径"><a href="#题目34：二叉树中和为某一值的路径" class="headerlink" title="题目34：二叉树中和为某一值的路径"></a>题目34：二叉树中和为某一值的路径</h3><ul><li><strong>题目描述</strong></li></ul><p>输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前)</p><ul><li><strong>分析</strong></li></ul><p>题干中的条件是找到从根节点到叶节点的路径，路径始终是从根节点开始，所以我们只能是前序遍历二叉树。当我们访问某一个子节点的时候，如果不是叶节点，那么就继续向下遍历，并将节点添加到路径，target为target减去当前接节点的值。如果是叶节点的话，判断是否符合条件，如果符合那么将路径添加。否则返回父节点，在返回时要将当前节点从路径中删去。</p><ul><li><strong>参考实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,<span class="keyword">int</span> target)&#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> res;</span><br><span class="line">        ArrayList&lt;Integer&gt; path = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        FindPath(root,target,res,path);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindPath</span><span class="params">(TreeNode root,<span class="keyword">int</span> target,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res,ArrayList&lt;Integer&gt; path)</span></span>&#123;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>&amp;&amp;root.val==target)&#123;</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;(path));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)FindPath(root.left,target-root.val,res,path);</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)FindPath(root.right,target-root.val,res,path);</span><br><span class="line">        &#125;</span><br><span class="line">        path.remove(path.size()-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="题目54：二叉搜索树的第K大节点"><a href="#题目54：二叉搜索树的第K大节点" class="headerlink" title="题目54：二叉搜索树的第K大节点"></a>题目54：二叉搜索树的第K大节点</h3><ul><li><strong>题目描述</strong></li></ul><p>给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8）    中，按结点数值大小顺序第三小结点的值为4。</p><ul><li><strong>分析</strong></li></ul><p>由二叉树的结构我们不难想到，二叉树的中序遍历序列是树节点的生序序列，如此我们只要得到中序遍历序列就可以找到第K大节点。主要考察的是树的遍历；</p><ul><li><strong>参考实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">TreeNode <span class="title">KthNode</span><span class="params">(TreeNode pRoot, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRoot==<span class="keyword">null</span>||k&lt;=<span class="number">0</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        TreeNode res=<span class="keyword">null</span>;</span><br><span class="line">        ArrayList&lt;TreeNode&gt; tmp=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        help(pRoot,tmp,k,res);</span><br><span class="line">        <span class="keyword">if</span>(tmp.size()&lt;k)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp.get(k-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">help</span><span class="params">(TreeNode root,ArrayList&lt;TreeNode&gt; tmp,<span class="keyword">int</span> k,TreeNode res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>||tmp.size()&gt;=k)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)help(root.left,tmp,k,res);</span><br><span class="line">        tmp.add(root);</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)help(root.right,tmp,k,res);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="题目55：二叉树的深度"><a href="#题目55：二叉树的深度" class="headerlink" title="题目55：二叉树的深度"></a>题目55：二叉树的深度</h3><ul><li><strong>题目描述</strong></li></ul><p>输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p><ul><li><strong>分析</strong></li></ul><p>该题与题34有一点相似，都是从根节点到叶节点进行遍历。所以该题也只能是前序遍历这个树，我们采用递归的方式实现。题目要求树的深度，定义一个全局变量表示当前树的最大深度，定义一个局部变量表示当前树的深度，递归之后返回树的最大深度即可。下面给出两种解法：</p><ul><li><strong>参考实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">public class TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val = 0;</span></span><br><span class="line"><span class="comment">    TreeNode left = null;</span></span><br><span class="line"><span class="comment">    TreeNode right = null;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public TreeNode(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">解法一：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> depth=<span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> path=<span class="number">0</span>;</span><br><span class="line">        TreeDepth(root,path);</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root,<span class="keyword">int</span> path)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(++path&gt;depth)depth=path;</span><br><span class="line">            <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>)TreeDepth(root.left,path);</span><br><span class="line">            <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>)TreeDepth(root.right,path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">解法二：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">TreeDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left_depth=TreeDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> right_depth=TreeDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> left_depth&gt;right_depth?left_depth+<span class="number">1</span>:right_depth+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="延伸题：平衡二叉树的判定"><a href="#延伸题：平衡二叉树的判定" class="headerlink" title="延伸题：平衡二叉树的判定"></a>延伸题：平衡二叉树的判定</h4><ul><li><strong>题目描述</strong></li></ul><p>输入一棵二叉树，判断该二叉树是否是<a href="https://baike.baidu.com/item/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91" target="_blank" rel="noopener">平衡二叉树</a>。</p><blockquote><p>平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有<a href="https://baike.baidu.com/item/%E7%BA%A2%E9%BB%91%E6%A0%91/2413209" target="_blank" rel="noopener">红黑树</a>、<a href="https://baike.baidu.com/item/AVL/7543015" target="_blank" rel="noopener">AVL</a>、<a href="https://baike.baidu.com/item/%E6%9B%BF%E7%BD%AA%E7%BE%8A%E6%A0%91/13859070" target="_blank" rel="noopener">替罪羊树</a>、<a href="https://baike.baidu.com/item/Treap" target="_blank" rel="noopener">Treap</a>、<a href="https://baike.baidu.com/item/%E4%BC%B8%E5%B1%95%E6%A0%91/7003945" target="_blank" rel="noopener">伸展树</a>等。</p></blockquote><ul><li><strong>分析</strong></li></ul><p>该题最直接的做法，遍历每个结点，借助一个获取树深度的递归函数，根据该结点的左右子树高度差判断是否平衡，然后递归地对左右子树进行判断。但是这样会重复遍历节点，我们可以简化一下，在判断当前子树不是平衡二叉树之后我们就直接返回，可以借助一个标志（-1）。</p><ul><li><strong>参考实现</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">IsBalanced_Solution</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getdepth(root)!=-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getdepth</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=getdepth(root.left);</span><br><span class="line">        <span class="keyword">if</span>(left==-<span class="number">1</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right=getdepth(root.right);</span><br><span class="line">        <span class="keyword">if</span>(right==-<span class="number">1</span>)<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left-right)&gt;<span class="number">1</span>?-<span class="number">1</span>:<span class="number">1</span>+Math.max(left,right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;题目12：矩阵中的路径&quot;&gt;&lt;a href=&quot;#题目12：矩阵中的路径&quot; class=&quot;headerlink&quot; title=&quot;题目12：矩阵中的路径&quot;&gt;&lt;/a&gt;题目12：矩阵中的路径&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="学习" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法与数据结构" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法题目" scheme="http://liutaiyu.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>华为实习生春招笔试（二）</title>
    <link href="http://liutaiyu.cn/2019/04/10/%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E7%94%9F%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://liutaiyu.cn/2019/04/10/华为实习生春招笔试（二）/</id>
    <published>2019-04-10T14:36:50.000Z</published>
    <updated>2019-04-11T00:54:56.375Z</updated>
    
    <content type="html"><![CDATA[<p>机试一共三道题：该题为其中第二道</p><p>题目描述：</p><blockquote><p>给定一个字符串，字符串包含数字、大小写字母以及括号（包括大括号、中括号和小括号），括号可以嵌套。默认括号是匹配的，数字后面一定有括号。按照以下规则展开字符串：</p><ol><li>数字表示括号里的字符串重复的次数，展开后的字符串不包括括号。</li><li>将字符串逆序展开</li></ol></blockquote><p>输入描述：</p><blockquote><p>输入一个长度小于100的字符串</p></blockquote><p>输出描述：</p><blockquote><p>输出展开后的字符串</p></blockquote><p>示例：</p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abc3(A)</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AAAcba</span><br></pre></td></tr></table></figure><p>思路：该题可以联想到数学式的混合运算的实现，借助栈来判断是否对当前数进行运算。本题中则是借助栈来判断是否对子结构进行一次字符串展开，子结构为: num（string）;算法思路如下：</p><ol><li>从左至右遍历字符串，如果没有遇到右括号，则入栈。</li><li>当遇到右括号时，将其与左括号之间的字符出栈并存入临时字符串，并且重复n次</li><li>将展开后的字符串入栈，重复1，直至遍历结束。</li><li>将栈中的字符串弹出，即为展开后的逆序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        String input = sc.nextLine();</span><br><span class="line"></span><br><span class="line">        String res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;String&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(input==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; input.length()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(input.charAt(i) == <span class="string">']'</span> </span><br><span class="line">               || input.charAt(i) == <span class="string">')'</span> </span><br><span class="line">               || input.charAt(i) == <span class="string">'&#125;'</span>)&#123;</span><br><span class="line">                String t = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">while</span> (!stack.peek().equals(<span class="string">"("</span>)</span><br><span class="line">                       &amp;&amp;!stack.peek().equals(<span class="string">"["</span>)</span><br><span class="line">                       &amp;&amp;!stack.peek().equals(<span class="string">"&#123;"</span>)) &#123;</span><br><span class="line">                    t = t + stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">int</span> s = Integer.valueOf(stack.pop());</span><br><span class="line">                String tmp =<span class="string">""</span>;</span><br><span class="line">                <span class="keyword">while</span> (s--&gt;<span class="number">0</span>)&#123;</span><br><span class="line">                    tmp +=t;</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(tmp);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                stack.push(String.valueOf(input.charAt(i++)));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">            res = res + stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;机试一共三道题：该题为其中第二道&lt;/p&gt;
&lt;p&gt;题目描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个字符串，字符串包含数字、大小写字母以及括号（包括大括号、中括号和小括号），括号可以嵌套。默认括号是匹配的，数字后面一定有括号。按照以下规则展开字符串：&lt;/p&gt;
&lt;ol
      
    
    </summary>
    
      <category term="学习" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法与数据结构" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法题目" scheme="http://liutaiyu.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>华为实习生春招笔试（一）</title>
    <link href="http://liutaiyu.cn/2019/04/10/%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E7%94%9F%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://liutaiyu.cn/2019/04/10/华为实习生春招笔试（一）/</id>
    <published>2019-04-10T13:59:50.000Z</published>
    <updated>2019-04-11T00:54:56.375Z</updated>
    
    <content type="html"><![CDATA[<p>机试一共三道题：该题为其中第一道</p><p>题目描述：</p><blockquote><p>给定n个字符串，对字符串按序每8个字符分割出一个子串，对于原字符串或者分割剩余的字符串长度不足8的，在末尾补0。要求按照自然排序输出所有新的字符串。</p></blockquote><p>输入描述：</p><blockquote><p>输入一个整数n，在输入n个字符串，相互之间空格隔开。</p></blockquote><p>输出描述：</p><blockquote><p>输出规定的字符串</p></blockquote><p>示例：</p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 abc 123456789</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12345678 90000000 abc00000</span><br></pre></td></tr></table></figure><p>思路：主要是字符串的操作和字符串长度以及边界条件的问题。对于每个字符串按要求将分割的子串添加到数组末尾，并删除当前字符串。最后排序输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> n = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n--&gt;<span class="number">0</span>) &#123;</span><br><span class="line">            strings.add(sc.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> size = strings.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;size; i++) &#123;</span><br><span class="line">            <span class="comment">//System.out.println(strings);</span></span><br><span class="line">            String tmp = strings.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> l = tmp.length();</span><br><span class="line">            <span class="keyword">int</span> s = l/<span class="number">8</span>;</span><br><span class="line">            <span class="keyword">int</span> ladd = <span class="number">8</span>-l%<span class="number">8</span>;</span><br><span class="line">            <span class="keyword">if</span>(ladd==<span class="number">8</span>)ladd=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(s&lt;<span class="number">1</span>||ladd==<span class="number">0</span>&amp;&amp;s==<span class="number">1</span>)<span class="keyword">break</span>;</span><br><span class="line">                strings.add(tmp.substring(<span class="number">8</span> * j, <span class="number">8</span> * (j+<span class="number">1</span>)));</span><br><span class="line">            &#125;</span><br><span class="line">            String last = s&lt;<span class="number">1</span>||ladd==<span class="number">0</span>&amp;&amp;s==<span class="number">1</span>?tmp:tmp.substring(s*<span class="number">8</span>);</span><br><span class="line">            <span class="keyword">while</span> (ladd-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                last = last + <span class="string">"0"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            strings.add(last);</span><br><span class="line">            strings.remove(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String[] str = strings.stream().toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">        Arrays.sort(str);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;str.length-<span class="number">1</span>)</span><br><span class="line">                System.out.print(str[i]+<span class="string">" "</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                System.out.print(str[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;机试一共三道题：该题为其中第一道&lt;/p&gt;
&lt;p&gt;题目描述：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定n个字符串，对字符串按序每8个字符分割出一个子串，对于原字符串或者分割剩余的字符串长度不足8的，在末尾补0。要求按照自然排序输出所有新的字符串。&lt;/p&gt;
&lt;/blockq
      
    
    </summary>
    
      <category term="学习" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法与数据结构" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法题目" scheme="http://liutaiyu.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>博客相关问题</title>
    <link href="http://liutaiyu.cn/2019/04/10/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>http://liutaiyu.cn/2019/04/10/博客相关问题/</id>
    <published>2019-04-10T07:52:36.000Z</published>
    <updated>2019-04-13T10:45:08.273Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#简写</span></span><br><span class="line">hexo n <span class="string">"我的博客"</span> == hexo new <span class="string">"我的博客"</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo g == hexo generate<span class="comment">#生成</span></span><br><span class="line">hexo s == hexo server <span class="comment">#启动服务预览</span></span><br><span class="line">hexo d == hexo deploy<span class="comment">#部署</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#服务器</span></span><br><span class="line">hexo server <span class="comment">#Hexo 会监视文件变动并自动更新，您无须重启服务器。</span></span><br><span class="line">hexo server -s <span class="comment">#静态模式</span></span><br><span class="line">hexo server -p <span class="number">5000</span> <span class="comment">#更改端口</span></span><br><span class="line">hexo server -i <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span> <span class="comment">#自定义 IP</span></span><br><span class="line"></span><br><span class="line">hexo clean <span class="comment">#清除缓存 网页正常情况下可以忽略此条命令</span></span><br><span class="line">hexo g <span class="comment">#生成静态网页</span></span><br><span class="line">hexo d <span class="comment">#开始部署</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#监视文件变动</span></span><br><span class="line">hexo generate <span class="comment">#使用 Hexo 生成静态文件快速而且简单</span></span><br><span class="line">hexo generate --watch <span class="comment">#监视文件变动</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#草稿</span></span><br><span class="line">hexo publish [layout] &lt;title&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">#模版</span></span><br><span class="line">hexo new <span class="string">"postName"</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo new page <span class="string">"pageName"</span> <span class="comment">#新建页面</span></span><br><span class="line">hexo generate <span class="comment">#生成静态页面至public目录</span></span><br><span class="line">hexo server <span class="comment">#开启预览访问端口（默认端口4000，'ctrl + c'关闭server）</span></span><br><span class="line">hexo deploy <span class="comment">#将.deploy目录部署到GitHub</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#例子</span></span><br><span class="line">hexo new [layout] &lt;title&gt;</span><br><span class="line">hexo new photo <span class="string">"My Gallery"</span></span><br><span class="line">hexo new <span class="string">"Hello World"</span> --lang tw</span><br><span class="line"></span><br><span class="line"><span class="comment">#推送到服务器上</span></span><br><span class="line">hexo n <span class="comment">#写文章</span></span><br><span class="line">hexo g <span class="comment">#生成</span></span><br><span class="line">hexo d <span class="comment">#部署 #可与hexo g合并为 hexo d -g</span></span><br></pre></td></tr></table></figure><h4 id="简易发布流程"><a href="#简易发布流程" class="headerlink" title="简易发布流程"></a>简易发布流程</h4><p>主要是通过配置一个alias命令来实现</p><p>例如博客文件夹的路径为 C:\blog_backup，将其替换为你自己的路径</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --<span class="keyword">global</span> alias.fuck <span class="string">'!cd C:\\blog_backup;hexo clean;hexo g -d'</span></span><br><span class="line">git fuck</span><br></pre></td></tr></table></figure><p>在任意目录打开git bash，就能够实现上述命令集；</p><p>如果要取消alias的话，可通过以下方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset alias.fuck</span><br></pre></td></tr></table></figure><p>个人设置了几个简易的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git blogview #更新博客内容并发布到本地服务器</span><br><span class="line">git blogupdate #更新博客内容并部署到网站</span><br><span class="line">git blognew #新建博客文章，初始化名字为“new title”</span><br></pre></td></tr></table></figure><h4 id="图床"><a href="#图床" class="headerlink" title="图床"></a>图床</h4><ul><li><p>先将图片文件上传至<a href="https://www.bmob.cn/" target="_blank" rel="noopener">bmob</a>，获取到图片链接后，直接在markdown中添加链接</p></li><li><p>图片命名格式：文章发布年月日-当天发表文章序号-文章内图片序号（说明）  </p><p>序号以0起始</p><p>例如：20190222-0-1.png</p></li></ul><h4 id="文章分类结构"><a href="#文章分类结构" class="headerlink" title="文章分类结构"></a>文章分类结构</h4><p>文章主类分为：学习、工作、生活、爱好</p><p>标签可自行添加</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Hexo常用命令&quot;&gt;&lt;a href=&quot;#Hexo常用命令&quot; class=&quot;headerlink&quot; title=&quot;Hexo常用命令&quot;&gt;&lt;/a&gt;Hexo常用命令&lt;/h4&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
      <category term="工作" scheme="http://liutaiyu.cn/categories/%E5%B7%A5%E4%BD%9C/"/>
    
    
      <category term="博客" scheme="http://liutaiyu.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络的性能</title>
    <link href="http://liutaiyu.cn/2019/02/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD/"/>
    <id>http://liutaiyu.cn/2019/02/22/计算机网络的性能/</id>
    <published>2019-02-22T02:21:47.000Z</published>
    <updated>2019-04-15T07:41:02.329Z</updated>
    
    <content type="html"><![CDATA[<p><strong>主要介绍常用的七个性能指标:</strong></p><h4 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h4><p>比特(bit)是计算机中数据量的单位，也是信息论中使用的信息量的单位。英文单词bit来源于binary digit，意思是一个“二进制数字”。网络技术中的速率指的是连接在计算机网络上的主机在数字信道上传送数据的速率，它也称为数据率(data rate)或比特率(bit rate)。时间的基本单位是s(秒)，因此单位是bit/s(比特/秒，有时也写作bps，即bit per second)。（1Gbit/s = 10^3Mbit/s = 10^6Kbit/s = 10^9bit/s）。</p><p><em>注意：在通信领域和计算机领域，应特别注意数量单位“千”、“兆”、“吉”等的英文缩写所代表的数值。计算机中的数量单位用字节作为度量单位，“千字节”的“千”用大写K表示，它等于2^10，即1024，而不是1000。</em></p><h4 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h4><h5 id="“带宽”有两种不同的意义："><a href="#“带宽”有两种不同的意义：" class="headerlink" title="“带宽”有两种不同的意义："></a>“带宽”有两种不同的意义：</h5><ol><li>带宽本来是指某个信号具有的频带宽度。信号的带宽是指该信号所包含的各种不同频率成份所占据的频率范围。这种意义的带宽的单位是赫。因此，表示通信线路允许通过的信号频带范围就称为线路的带宽(或通频带)。</li><li>在计算机网络中，带宽用来表示网络的通信线路传送数据的能力，因此网络带宽表示单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。这种意义的带宽的单位是比特/秒。</li></ol><p>   在“带宽”的两种表述中，前者为频域称谓，而后者为时域称谓，其本质是相同的。也就是说，一条通信链路的“带宽”越宽，其所能传输的“最高数据率”也越高。</p><p>   <em>注意：宽带运行商和电脑对宽带的速度单位是不一样的，电脑的单位是KBbs，而宽带运营商的单位是Kbbs，1B = 8b。例如你从宽带运营商那里办理了10M的宽带。  10Mbps = 10240Kbps / 8 = 1280KBps.</em></p><h5 id="上行带宽和下行带宽，或者说上行速度和下行速度是什么意思"><a href="#上行带宽和下行带宽，或者说上行速度和下行速度是什么意思" class="headerlink" title="上行带宽和下行带宽，或者说上行速度和下行速度是什么意思?"></a>上行带宽和下行带宽，或者说上行速度和下行速度是什么意思?</h5><p>   我们访问互联网的过程中存在这两种行为：一是上传数据，二是下载数据。上行宽带(速度)指的是上传的速度，而下行宽带(速度)指的是下载数据是的数度。</p><p>  上行宽带(速度)和下行宽带(速度)是不对称的，一般是下行速度大于上行的速度。我们平时所使用的宽带说多少M，都是指的下行宽带，因为我们上网主要是从互联网上下载数据，而上传的数据量要少很多。</p><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p>   吞吐量(throughput)表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量受网络带宽或网络的额定速率的限制。吞吐量更经常的用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。</p><h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><p>   时延(delay 或 latency)是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。时延是个很重要的性能指标。网络中的时延由以下几个不同的部分组成：</p><ol><li><strong>发送时延</strong>：指主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需要的时间。发生在机器内部的发生器中,与传输信道的长度没有任何关系。<blockquote><p>发送时延计算公式：数据帧的长度(bits) / 发送速率(bits/s)</p></blockquote></li></ol><p>由此可见发送时延与发送的帧长成正比，与发送速率成反比。</p><ol><li><strong>传播时延</strong>：指电磁波在信道中传播一定距离需要花费的时间。</li></ol><blockquote><p>传播时延计算公式：信道长度(m) / 电磁波在信道上的传播速率(m/s)</p><p>电磁波在自由空间传播速率是光速：3.0×10^5km/s，铜线电缆中：2.3×10^5km/s，光纤中：2.0×10^5km/s。传播时延与信号的发送速率无关。信号传送的距离越远，传播时延就越大。    </p><ol><li><strong>处理时延</strong>：主机或路由器在收到分组时要花费一定的时间进行处理，例如分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等等。</li></ol></blockquote><ol><li><strong>排队时延</strong>：分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发。这就产生了排队时延。<blockquote><p>总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延</p></blockquote></li></ol><p><em>注意：由于时延由以上四部分组成，所以不能笼统地认为：“数据的发送速率越高，传送得就越快”。同时需要特别注意一个错误观念：“在高速链路，比特应当跑得更快些”。这是不对的，因为对于高速网络链路，我们提高的仅仅是数据的发送速率，而不是比特在链路上的传播速率。提高数据的发送速率只是减少了数据的发送时延。而传播速率的单位是每秒传输多少公里，是指传输线路上比特的传播速率，通常是由线路决定而不变的。</em></p><h4 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h4><blockquote><p>时延带宽积 = 传播时延 × 带宽</p></blockquote><p>时延带宽积表示链路可容纳的比特数，因此，链路的时延带宽积又称为以比特为单位的链路长度。</p><h4 id="往返时间RTT"><a href="#往返时间RTT" class="headerlink" title="往返时间RTT"></a>往返时间RTT</h4><p>  往返时间RTT，表示从发送方发送数据开始，到发送方收到来自接收方的确认（接收方收到数据后便立即发送确认），总共经历的时间。往返时间一般就会包括分组在网络中的各种时延。</p><h4 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h4><p>利用率由信道利用率和网络利用率两种。信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。网络的利用率则是全网络的信道利用率的加权平均值。信道利用率并非越高越好，这是因为，根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也会迅速增加。信道或网络的利用率过高会产生非常大的时延。</p><p><img src="https://o9zqaq.ch.files.1drv.com/y4mjZRdZUMMm4JDkX4UaejxiStQ9acRYtOaOmPO1JjLPj-BZJ-rwKY9HkNTP3EI5vit2Rdod1POexWkevjduoXcXF6MrzLsPwmUvF1jWxv6g8R4Zt2rOrKzehAKIOKmbgmCwlfPrtPL6JnsxnlXvCBWd9A3JC_95-MSixJqP7rd9OiHTSlkndTeHF2LZ5Y7tpwPRdC6AEWuPMRmbchV3vhpFA?width=368&amp;height=267&amp;cropmode=none" alt="时延与利用率的关系"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;主要介绍常用的七个性能指标:&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;速率&quot;&gt;&lt;a href=&quot;#速率&quot; class=&quot;headerlink&quot; title=&quot;速率&quot;&gt;&lt;/a&gt;速率&lt;/h4&gt;&lt;p&gt;比特(bit)是计算机中数据量的单位，也是信息论中使用的信息量
      
    
    </summary>
    
      <category term="学习" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="计算机基础" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="计算机网络" scheme="http://liutaiyu.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode148-排序链表</title>
    <link href="http://liutaiyu.cn/2018/11/05/LeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://liutaiyu.cn/2018/11/05/LeetCode148-排序链表/</id>
    <published>2018-11-05T09:03:36.000Z</published>
    <updated>2019-04-24T04:06:41.338Z</updated>
    
    <content type="html"><![CDATA[<p>题目来源：<a href="https://leetcode-cn.com/problems/sort-list/description/" target="_blank" rel="noopener">148. 排序链表</a><br><strong>在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。</strong><br><strong>示例1:</strong></p><blockquote><p>输入: 4-&gt;2-&gt;1-&gt;3<br>  输出: 1-&gt;2-&gt;3-&gt;4</p></blockquote><p><strong>示例2:</strong></p><blockquote><p>输入: -1-&gt;5-&gt;3-&gt;4-&gt;0<br>  输出: -1-&gt;0-&gt;3-&gt;4-&gt;5</p></blockquote><p>思路：考查链表的排序，要求的时间复杂度可以联想到快速排序、堆排序、归并排序。由于是链表，我们选择二分归并排序比较容易实现。以下是Java的两种实现。</p><p>解法一：常规的插入排序，用时较多<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode root=<span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        root.next=head;</span><br><span class="line">        ListNode p=head;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="keyword">null</span>&amp;&amp;p.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val&lt;=p.next.val)&#123;p=p.next;&#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ListNode tmp=root,q=p.next;</span><br><span class="line">                <span class="keyword">while</span>(tmp.next.val&lt;=q.val)&#123;</span><br><span class="line">                    tmp=tmp.next;</span><br><span class="line">                &#125;                </span><br><span class="line">                p.next=q.next;</span><br><span class="line">                q.next=tmp.next;</span><br><span class="line">                tmp.next=q;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root.next;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>解法二：二分归并排序,用时较少<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">sortList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">return</span> mergeSort(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ListNode <span class="title">mergeSort</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(head==<span class="keyword">null</span> || head.next==<span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"><span class="comment">//分治</span></span><br><span class="line">ListNode p1 = head;</span><br><span class="line">ListNode p2 = head;</span><br><span class="line"><span class="comment">//遍历对链表二分</span></span><br><span class="line"><span class="keyword">while</span>(p2.next!=<span class="keyword">null</span> &amp;&amp; p2.next.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">p1 = p1.next;</span><br><span class="line">p2 = p2.next.next;</span><br><span class="line">&#125;</span><br><span class="line">ListNode left = head; <span class="comment">//左子链</span></span><br><span class="line">ListNode right = p1.next; <span class="comment">//右子链</span></span><br><span class="line">p1.next = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//排序子链表</span></span><br><span class="line">left = mergeSort(left);</span><br><span class="line">right = mergeSort(right);</span><br><span class="line"><span class="comment">//合并</span></span><br><span class="line"><span class="keyword">if</span>(left==<span class="keyword">null</span>) <span class="keyword">return</span> right;</span><br><span class="line"><span class="keyword">if</span>(right==<span class="keyword">null</span>) <span class="keyword">return</span> left;</span><br><span class="line"></span><br><span class="line">ListNode h = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">ListNode p = h;</span><br><span class="line"><span class="comment">//对左右两数进行比较</span></span><br><span class="line"><span class="keyword">while</span>(left!=<span class="keyword">null</span> &amp;&amp; right!=<span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(left.val&lt;right.val)&#123;</span><br><span class="line">p.next = left;</span><br><span class="line">left = left.next;</span><br><span class="line">p = p.next;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">p.next = right;</span><br><span class="line">right = right.next;</span><br><span class="line">p = p.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(left==<span class="keyword">null</span>) p.next = right;</span><br><span class="line"><span class="keyword">else</span> p.next = left;</span><br><span class="line"><span class="keyword">return</span> h.next; <span class="comment">//返回表头</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目来源：&lt;a href=&quot;https://leetcode-cn.com/problems/sort-list/description/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;148. 排序链表&lt;/a&gt;&lt;br&gt;&lt;strong&gt;在 O(n log 
      
    
    </summary>
    
      <category term="学习" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="算法与数据结构" scheme="http://liutaiyu.cn/categories/%E5%AD%A6%E4%B9%A0/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="算法题目" scheme="http://liutaiyu.cn/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"/>
    
      <category term="medium" scheme="http://liutaiyu.cn/tags/medium/"/>
    
  </entry>
  
</feed>
