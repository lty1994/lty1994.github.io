<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于博客]]></title>
    <url>%2F2018%2F11%2F06%2F%E5%85%B3%E4%BA%8E%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[折腾了三天的博客，今天总算是告一段落了。搭建个人博客的目的其实很简单，就是为了记录自己学习的点点滴滴。当然过程中也对域名使用、git版本控制、markdown编辑也有了更深的理解和实践。目前的博客就是这样了，非常简单的使用hexo，之后有时间再来美化了。庆祝一下Heitu的博客正式开通！！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[148.排序链表]]></title>
    <url>%2F2018%2F11%2F05%2F148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目来源：148. 排序链表在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。示例1: 输入: 4-&gt;2-&gt;1-&gt;3 输出: 1-&gt;2-&gt;3-&gt;4 示例2: 输入: -1-&gt;5-&gt;3-&gt;4-&gt;0 输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 思路：考查链表的排序，要求的时间复杂度可以联想到快速排序、堆排序、归并排序。由于是链表，我们选择二分归并排序比较容易实现。以下是Java的两种实现。 解法一：常规的插入排序，用时较多12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode sortList(ListNode head) &#123; ListNode root=new ListNode(0); root.next=head; ListNode p=head; while(p!=null&amp;&amp;p.next!=null)&#123; if(p.val&lt;=p.next.val)&#123;p=p.next;&#125; else&#123; ListNode tmp=root,q=p.next; while(tmp.next.val&lt;=q.val)&#123; tmp=tmp.next; &#125; p.next=q.next; q.next=tmp.next; tmp.next=q; &#125; &#125; return root.next; &#125;&#125; 解法二：二分归并排序,用时较少1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode sortList(ListNode head) &#123; if(head==null || head.next==null) return head; return mergeSort(head); &#125; private static ListNode mergeSort(ListNode head)&#123; if(head==null || head.next==null) return head; //分治 ListNode p1 = head; ListNode p2 = head; //遍历对链表二分 while(p2.next!=null &amp;&amp; p2.next.next!=null)&#123; p1 = p1.next; p2 = p2.next.next; &#125; ListNode left = head; //左子链 ListNode right = p1.next; //右子链 p1.next = null; //排序子链表 left = mergeSort(left); right = mergeSort(right); //合并 if(left==null) return right; if(right==null) return left; ListNode h = new ListNode(-1); ListNode p = h; //对左右两数进行比较 while(left!=null &amp;&amp; right!=null)&#123; if(left.val&lt;right.val)&#123; p.next = left; left = left.next; p = p.next; &#125;else&#123; p.next = right; right = right.next; p = p.next; &#125; &#125; if(left==null) p.next = right; else p.next = left; return h.next; //返回表头 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>Leetcode</tag>
      </tags>
  </entry>
</search>
