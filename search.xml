<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode82-已序链表中删除重复项]]></title>
    <url>%2F2019%2F04%2F28%2FLeetCode82-%E5%B7%B2%E5%BA%8F%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%88%A0%E9%99%A4%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[题目：82-已序链表中删除重复项题目描述给定一个排序链表，删除所有含有重复数字的节点，只保留原始链表中 没有重复出现* 的数字。 示例 1、 输入: 1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;4输出: 1-&gt;2 2、 输入: 1-&gt;1-&gt;1-&gt;2-&gt;3输出: 2-&gt;3 思路该题考察链表的遍历操作，可以添加两个辅助指针，用来分别指向重复项的起点和终点（这里我们不直接指向操作的节点，而是对指针的后继节点进行判断，这样可以避免尾结点空的问题，示例1）定位之后将重复节点丢弃即可。在头指针在遍历的时候要注意判断空值。链表指针一直向后遍历，所以时间复杂度为O(n) 参考实现12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; if(head==null||head.next==null)return head; ListNode front = new ListNode(-1); front.next=head; ListNode last = front; while(head.next!=null)&#123; if(front.next.val!=head.next.val)&#123;//判断是否重复 front=front.next; &#125;else&#123; while(head.next!=null&amp;&amp;front.next.val==head.next.val)&#123;//获取最后一个重复节点 head=head.next; &#125; front.next=head.next;//丢弃重复节点 &#125; if(head.next!=null)head=head.next;//向后遍历链表 &#125; return last.next; &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法题目</tag>
        <tag>LeetCode-medium</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo添加各种功能]]></title>
    <url>%2F2019%2F04%2F28%2FHexo%E6%B7%BB%E5%8A%A0%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[下载功能在博客书写过程中，我们往往会在文末提供附件。在网上搜索了一下方法，主要是通过网盘，上传文件，然后分享链接下载。通过网盘的方式可能还需要你注册网盘等等，操作有时候很麻烦。这里记录一个比较简洁的办法 方法 在source目录下新建dounload文件夹，将需要上传的文件xx.xx复制到该目录。 在_posts博文中，插入： [ 点击下载](/download/xx.xls”)链接 示例这里放了大湾区规划纲要：粤港澳大湾区发展规划纲要.pdf 参考链接hexo添加下载功能 Hexo中提供文件下载功能 添加视频和GIF图片12&lt;iframe height=100 width=100 src="视频地址"&gt;&lt;iframe height=100 width=100 src="gif 图片地址"&gt; 例如:]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode51-N皇后]]></title>
    <url>%2F2019%2F04%2F24%2FLeetCode51-N%E7%9A%87%E5%90%8E%2F</url>
    <content type="text"><![CDATA[题目：51-N皇后问题题目描述n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。这个问题的由来其实是八皇后问题，这个问题非常经典。 上图为 8 皇后问题的一种解法。 给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 &#39;Q&#39; 和 &#39;.&#39; 分别代表了皇后和空位。 示例 输入: 4输出: [ [“.Q..”, // 解法 1 “…Q”, “Q…”, “..Q.”], [“..Q.”, // 解法 2 “Q…”, “…Q”, “.Q..”]]解释: 4 皇后问题存在两个不同的解法。 思路在理解了八皇后问题之后，我们不难发现，每行放置一个且仅一个皇后。每放置一个皇后，则棋盘上与该皇后在同列和斜线上（与皇后位置行差和列差的绝对值相等）的位置无法再放置皇后。基于此，我们可以遍历每一行所有的列，如果该列可以放置，则标记（这个标记我们可以用一位数组来表示，索引代表行，值代表该行皇后放置的列），然后放置下一行的皇后。可见子问题是重复的，我们可以用回溯的方法来实现。同时不难发现，当n&lt;4且不等于1时，问题是无解的。 参考实现1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; static List&lt;List&lt;String&gt;&gt; res= new ArrayList&lt;&gt;(); public List&lt;List&lt;String&gt;&gt; solveNQueens(int n) &#123; res.clear(); List&lt;String&gt; sol=new ArrayList&lt;&gt;(); if(n==2||n==3)&#123;return res;&#125; else if(n==1)&#123;sol.add("Q");res.add(sol);return res;&#125; else&#123; List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;(); getsol(n,0,tmp); return res; &#125; &#125; public static void getsol(int n, int row, List&lt;Integer&gt; tmp) &#123; if(n==row)&#123;//如果遍历完所有行,则为一种解法 List&lt;String&gt; path = new ArrayList&lt;&gt;(); for (Integer i : tmp) &#123; String string=""; for (int j = 0; j &lt; n; j++) &#123; if(j==i)&#123; string+="Q"; &#125;else&#123; string+="."; &#125; &#125; path.add(string); &#125; res.add(path); &#125; A:for (int i = 0; i &lt; n; i++) &#123; if(!tmp.contains(i))&#123;//判断该列是否有皇后 for (int j = 0; j &lt; row; j++) &#123;//判断该点斜线上是否有皇后,如果有,则继续下一列 if(row-j==Math.abs(i-tmp.get(j)))&#123; continue A; &#125; &#125; tmp.add(i); getsol(n, row + 1, tmp);//查找下一行皇后的位置 tmp.remove(tmp.size() - 1);//下一行所有列都无法放置,则回溯,进入当前行下一列 &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法题目</tag>
        <tag>LeetCode-hard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python笔记]]></title>
    <url>%2F2019%2F04%2F21%2FPython%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Python多元赋值python中有一种赋值机制即多元赋值，采用这种方式赋值时，等号两边的对象都是元组并且元组的小括号是可选的。通常形式为： x, y, z = 1, 2, ‘a string’ 等同于 (x, y, z) = (1, 2, ‘a string’) 这种赋值类型最经常用到的环境是变量交换，形如 x, y = y, x 这种交换方式无需中间变量即可交换两个变量的值。那么具体实现机制是怎样的呢？ 运行时，首先构造一个元组(y, x)，然后构造另一个元组(x, y)，接着用元组(y, x)赋值给(x, y)，元组赋值过程从左到右，依次进行。假如x=1,y=2，先令x=y,此时x=2,然后令y=x,y应该等于2？那么就不能实现变量交换了？对于这个问题，应该从元组的特性说起。 x, y, z = 1, 2, ‘a string’tuple = (x, y, z) 变量名x, y, z都是引用，内存开辟除了三个空间分别存储1, 2, ‘a string’，三个变量分别指向这三块地址。由这三个变量构造的元组tuple，它有三个元素，这三个元素并不是x,y,z这三个变量，而是这三个变量所指向的地址空间里的内容。如果此时再另x=4,此时在地址空间会另开辟出一块空间存储4，x进而指向这块空间，而元组内的三个值仍保持不变。所以对于 x, y = y, x 来说，首先由y,x所构成的元组(y,x)其实应该表示为(2,1),那么再从左到右赋值，就可以交换变量的值了。 对于此，LeetCode中有一道链表反转的题目，借助多元赋值可以使代码非常简洁。给出实现代码： 123456789101112# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def reverseList(self, head: ListNode) -&gt; ListNode: p, rev = head, None while p: rev, rev.next, p = p, rev, p.next return rev]]></content>
      <categories>
        <category>学习</category>
        <category>计算机语言</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ROS常用命令记录]]></title>
    <url>%2F2019%2F04%2F17%2FROS%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[主机和相关组件：roscoreroscore是一个向节点提供连接信息，以便节点间可以相互传递信息的服务程序。同时，它也提供了一个被节点广泛用于程序配置的参数服务器（参数服务器允许节点存储和获取任意数据结构，有命令rosparam用于交互）。它主要作用在于： 每个节点都在启动时连接到roscore并注册该节点发布和订阅的消息 roscore向新节点提供与其他发布并订阅相同消息主题的节点建立点对点连接的必要信息 每一个ROS都需要roscore，否则节点之间无法互相找到 当ROS启动时，我们会首先执行roscore，该进程含有一个名为ROS_MASTER_URI的环境变量，这是一个格式为http://hostname:11311/的字符串，表示roscore有一个实例可以通过这个URI在网络中进行访问。而roscore实际上则启动了三个工具： 主机，处理系统中的各类名称管理。维护一个关于节点名称和网络地址的映射列表。 参数服务器，管理系统中各参数设置的键值对数据 rosout节点，收集其他各个节点的调试信息 已知roscore的网络位置后，节点在roscore完成注册（提供节点的网络地址）并请求roscore通过命名找到其他节点和数据流。 节点告诉roscore该节点发布和订阅的消息信息 roscore向节点提供相关消息的生产者和使用者的地址 上图中的节点周期性的调用roscore来确保相互之间能被找到，而交换点到点消息是两个节点直接完成的。 参数管理：rosparam文件系统：roscdrospack rospack find 查找包的路径 节点启动单节点启动：rosrun多节点启动：roslaunch多节点系统测试：rostest系统监控节点监控：rosnode话题监控：rostopic服务监控：rosservice服务请求和响应类型：rossrv日志消息/rosout和/rosout_agg数据记录和分析rosbagrostopic echo -b可视化工具日志消息：rqt_console节点、话题和连接：rqt_graph数据图表：rqt_plot话题数据可视化：rqt_bag仿真工具：rviz]]></content>
      <categories>
        <category>学习</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>ROS</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策树基础]]></title>
    <url>%2F2019%2F04%2F15%2F%E5%86%B3%E7%AD%96%E6%A0%91%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[决策树（Decision Tree）决策树是一种基本的分类和回归的方法，它是一种树形结构。其每个非叶节点表示一个特征属性上的测试，每个分支代表这个特征属性在其取值范围内的某一输出，而每个叶节点存放一个类别。 决策树进行决策的过程就是从根节点开始，测试待分类项中相应的特征属性，并按照其值选择输出分支，直到到达叶子节点，将叶子节点存放的类别作为决策结果。 决策树学习本质上是从训练数据集中归纳出一组分类规则。通常用损失函数表示这一目标，损失函数通常是正则化的极大似然函数，学习的策略是以损失函数为目标函数的最小化。学习的算法一般是启发式方法，近似求解最优值。学习算法是一个递归选择最优特征的过程。为了避免最后学习到的决策树发生过拟合现象，我们通常使用验证集来对学习到的决策树进行剪枝，使其有更好的泛化能力。 决策树的结构有以下特点： 结点和有向边组成 结点有内部结点和叶结点俩种类型 内部结点表示一个特征，叶节点表示一个类，边表示该特征下可能的输出值 决策树学习的步骤通常包括： 特征选择 决策树的生成 决策树的剪枝 下面从决策树学习的三个步骤介绍决策树模型的原理： 特征选择特征选择的目的在于选取对训练数据能够分类的特征，常用的特征选择算法有ID.3、C4.5和基尼系数，相关的公式如下： ID.3样本集合D对特征A的信息增益 g(D,A)=H(D)-H(D|A)\\ H(D)=-\sum_{k=1}^{K}\frac{\left | C_{k} \right |}{\left | D \right |}\log_{2}\frac{\left | C_{k} \right |}{\left | D \right |}\\ H(D|A)=-\sum_{i=1}^{n}\frac{\left | D_{i} \right |}{\left | D \right |}H(D_{i})其中$H(D)$是数据集D的熵，H(D_i)是数据集D_i的熵，$H(D|A)$是数据集D对特征A的条件熵。D_i是D中特征A取第i个值的样本子集，C_k是D中属于第k类的样本子集。n是特征A取值的个数，K是类的个数。 C4.5 g_{R}(D,A)=\frac{g(D,A)}{H_{A}(D)}其中，$g(D,A)$是信息增益，$H_{A}(D)$是D关于特征A的值的熵。 CART（分类问题） Gini(D)=1-\sum_{k=1}^{K}\left ( \frac{\left | C_{k} \right |}{\left | D \right |} \right )^2特征A条件下集合D的基尼系数： Gini(D,A)=\frac{\left | D_{1} \right |}{\left | D \right |}Gini(D_{1})+\frac{\left | D_{2} \right |}{\left | D \right |}Gini(D_{2})决策树的生成通常使用上述特征选择的方法，从根节点开始，递归的生成决策树。这里主要讲一下CART回归树的生成，CART对回归树用平方误差最小化准则，对分类树用基尼系数最小化准则，进行特征选择，生成树。 回归树假设X,Y为输入和输出，Y为连续变量。假设我们将输入空间划分为M个单元$R_1…R_M​$，并且每个单元$R_m​$上有一个固定的输出值${c_m}​$，模型可以表示为： f(x)=\sum_{m=1}^{M}c_{m}I(x\in{R_{m}})我们可以用平方误差\sum_{x_{i}\in{R_{m}}}{(y_{i}-f(x_{i}))^2}​来表示回归树的训练误差，易知单元{R_m}​上的{c_m}​的最优值是单元上所有输入实例对应的输出值的均值： \hat c_m=ave(y_i|x_i \in{R_m})对于空间的划分，我们选择第j个特征$x^{(j)}$和它的取值s，并定义两个区域： R_1(j,s)=\{x|x^{(j)}\leq s\}\hspace{3em}\hat R_2(j,s)=\{x|x^{(j)}> s\}然后求解： \min_{j,s}\left [ \min_{c_1}\sum_{x_{i}\in{R_{1}(j,s)}}(y_{i}-c_1)^2 +\min_{c_2}\sum_{x_{i}\in{R_{2}(j,s)}}(y_{i}-c_2)^2 \right ]对于固定的输入变量j，可以找到s. \hat c_m=\frac{1}{N_m}\sum_{x_i \in{R_{m}(j,s)}}y_i\hspace{1em}(x\in R_m,m=1,2)然后遍历j，找到最优的（j，s）对。然后依据此对空间做一次划分，重复上述过程。这样生成的树我们通常称为最小二乘回归树。每一次划分后，下一次拟合的是残差。 决策树的剪枝决策树的剪枝通过极小化决策树整体的Loss来实现，假设决策树T的叶节点个数为|T|，t是树T的叶节点，该叶节点有N_t个样本点，其中k类的样本点有N_{tk}个，k=1,2,...,K，H_{t}(T)为叶节点t上的经验熵，\alpha \geq 0为参数，则决策树学习的损失函数定义为：其中经验熵为：H_{t}(T)=-\sum_{k=1}^{K}\frac{N_{tk}}{N_{t}}\log \frac{N_{tk}}{N_{t}} \begin{align} C_{\alpha}(T)&=\sum_{t=1}^{|T|}N_{t}H_{t}(T)+\alpha|T|\\ &=-\sum_{t=1}^{|T|}\sum_{k=1}^{K}N_{tk}\log \frac{N_{tk}}{N_{t}}+\alpha|T|\\ &=C(T)+\alpha|T| \end{align}上式中C(T)表示模型对训练数据的预测误差，即模型和训练数据的拟合程度，|T|表示模型的复杂度。剪枝就是当α确定时，选择损失函数最小的模型，即损失函数最小的子树。 算法： 输入：生成树T，参数α 输出：修剪后的子树$T_{\alpha}​$ 计算每个节点的经验熵 递归的从树的叶节点向上回缩，如果回缩到父节点前后的损失函数值不增加，那么进行剪枝，将父节点变为新的叶节点 返回2，直至不能继续，得到损失函数最小的子树$T_{\alpha}$]]></content>
      <categories>
        <category>学习</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>监督学习</tag>
        <tag>算法模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo中使用Latex公式]]></title>
    <url>%2F2019%2F04%2F13%2FHexo%E4%B8%AD%E4%BD%BF%E7%94%A8Latex%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[使用公式插入格式： 12$数学公式$ 行内 不独占一行$$数学公式$$ 行间 独占一行 例如： 1234$f(x)=ax+b$ #行内显示$$f(x)=ax+b #行间显示$$ 显示效果为：$f(x)=ax+b​$ 行间使用则为： f(x)=ax+b语法格式上标与下标使用 ^ 表示上标，使用 _ 表示下标，如果上下标的内容多于一个字符，可以使用大括号括起来： 1$$f(x) = a_1x^n + a_2x^&#123;n-1&#125; + a_3x^&#123;n-2&#125;$$ 显示效果为： f(x) = a_1x^n + a_2x^{n-1} + a_3x^{n-2}如果左右两边都有上下标可以使用 \sideset 语法： 1$$\sideset&#123;^n_k&#125;&#123;^x_y&#125;a$$ \sideset{^n_k}{^x_y}a括号在 markdown 语法中，\, $, {, }, _都是有特殊含义的，所以需要加\转义。小括号与方括号可以使用原始的() [] 大括号需要转义\也可以使用\lbrace和 \rbrace 12\&#123;x*y\&#125;\lbrace x*y \rbrace 显示效果为：$\lbrace x*y \rbrace$ 原始符号不会随着公式大小自动缩放，需要使用 \left 和 \right 来实现自动缩放： 1$$\left \lbrace \sum_&#123;i=0&#125;^n i^3 = \frac&#123;(n^2+n)(n+6)&#125;&#123;9&#125; \right \rbrace$$ 效果(加上了\left 和 \right):$\left \lbrace \sum_{i=0}^n i^3 = \frac{(n^2+n)(n+6)}{9} \right \rbrace$ 没加的效果：$ \lbrace \sum_{i=0}^n i^3 = \frac{(n^2+n)(n+6)}{9} \rbrace$ 分数与开方可以使用\frac 或者 \over 实现分数的显示： 12$\frac xy$$ x+3 \over y+5 $ 分别显示为： $\frac xy$ $ x+3 \over y+5 $ 开方使用\sqrt: 12$ \sqrt&#123;x^5&#125; $$ \sqrt[3]&#123;\frac xy&#125; $ 显示为：$ \sqrt{x^5} $ $ \sqrt[3]{\frac xy} $ 求和与积分求和使用\sum,可加上下标，积分使用\int可加上下限，双重积分用\iint: 123$ \sum_&#123;i=0&#125;^n $$ \int_a ^ b $$ \iint_1 ^ \infty $ 分别显示：$ \sum_{i=0}^n $ $ \int_a^b $ $ \iint_1^\infty $ 极限极限使用\lim: $ \lim_{x \to 0} $ 1$ \lim_&#123;x \to 0&#125; $ 表格与矩阵表格样式lcr表示居中，|加入一条竖线，\hline表示行间横线，列之间用&amp;分隔，行之间用\分隔： \begin{array}{c|lcr} n & \text{Left} & \text{Center} & \text{Right} \\\\ \hline 1 & 1.97 & 5 & 12 \\\\ 2 & -11 & 19 & -80 \\\\ 3 & 70 & 209 & 1+i \\\\ \end{array}1234567$$\begin&#123;array&#125;&#123;c|lcr&#125;n &amp; \text&#123;Left&#125; &amp; \text&#123;Center&#125; &amp; \text&#123;Right&#125; \\\\\hline1 &amp; 1.97 &amp; 5 &amp; 12 \\\\2 &amp; -11 &amp; 19 &amp; -80 \\\\3 &amp; 70 &amp; 209 &amp; 1+i \\\\\end&#123;array&#125;$$ 矩阵: 123456789101112131415161718192021$$\left[\begin&#123;matrix&#125;V_A \\\\V_B \\\\V_C \\\\\end&#123;matrix&#125;\right] =\left[\begin&#123;matrix&#125;1 &amp; 0 &amp; L \\\\-cosψ &amp; sinψ &amp; L \\\\-cosψ &amp; -sinψ &amp; L\end&#123;matrix&#125;\right]\left[\begin&#123;matrix&#125;V_x \\\\V_y \\\\W \\\\\end&#123;matrix&#125;\right] $$ 显示效果： \left[ \begin{matrix} V_A \\\\ V_B \\\\ V_C \\\\ \end{matrix} \right] = \left[ \begin{matrix} 1 & 0 & L \\\\ -cosψ & sinψ & L \\\\ -cosψ & -sinψ & L \end{matrix} \right] \left[ \begin{matrix} V_x \\\\ V_y \\\\ W \\\\ \end{matrix} \right]换行问题（换行，等号对齐）公示太长需要换行的问题，并且是连等公示，每个等号在还行之后都需要对齐。 可以使用： 其中aligned就是用来公式对齐的，在中间公式中，\\ 表示换行， &amp; 表示对齐。在公式中等号之前加&amp;，等号介绍要换行的地方加\\就可以了。 1234567891011121314\begin&#123;equation&#125;\begin&#123;aligned&#125;......\end&#123;aligned&#125;\end&#123;equation&#125;例如：\begin&#123;equation*&#125;%加*表示不对公式编号\begin&#123;split&#125;PMV =&amp;[0.303*exp(-0.036M)+0.0275]*\&#123;M-W-3.05*[5.733-\\&amp;0.007(M-W)-P_a]-0.42*(M-W-58.2)-0.0173M*\\&amp;(5.867-P_a)-0.0014M*(34-t_a)-3.96*10^-8*f_cl*[(t_cl+\\&amp;273)^4-(t_r+273)^4]-f_cl*h_c*(t_cl-t_a)\&#125;\end&#123;split&#125;\end&#123;equation*&#125; \begin{equation*}%加*表示不对公式编号 \begin{split} PMV =&[0.303*exp(-0.036M)+0.0275]*\{M-W-3.05*[5.733-\\ &0.007(M-W)-P_a]-0.42*(M-W-58.2)-0.0173M*\\ &(5.867-P_a)-0.0014M*(34-t_a)-3.96*10^-8*f_cl*[(t_cl+\\ &273)^4-(t_r+273)^4]-f_cl*h_c*(t_cl-t_a)\} \end{split} \end{equation*}参考：http://stevenshi.me/2017/06/26/hexo-insert-formula/]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer题集笔记]]></title>
    <url>%2F2019%2F04%2F13%2F%E5%89%91%E6%8C%87offer%E9%A2%98%E9%9B%86%2F</url>
    <content type="text"><![CDATA[题目12：矩阵中的路径 题目描述 请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一个格子开始，每一步可以在矩阵中向左，向右，向上，向下移动一个格子。如果一条路径经过了矩阵中的某一个格子，则之后不能再次进入这个格子。 例如 a b c e s f c s a d e e 这样的3 X 4 矩阵中包含一条字符串”bcced”的路径，但是矩阵中不包含”abcb”路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入该格子。 分析 该类问题可以用回溯法来求解，回溯法非常适合由多个步骤组成的问题，并且每个步骤都有多个选项。当我们在某一步选择了其中一个选项时，我们进入下一步，然后又面临新的选项。重复直至到达最终的状态。 该题过程主要如下： 遍历矩阵中的所有节点（因为题目允许从任何一个格子开始），对于其中一个节点作为起始节点，然后向四周（符合回溯的条件）寻找下一个和字符串匹配的节点，如果有，那么继续向后寻找路径，如果没有，则遍历下一个节点作为起始节点。直至遍历完所有节点。 过程中我们需要一个标志位来标记节点是否已为路径上的节点，和一个整数保存路径的长度。要注意的是如果该节点四周没有可以继续的路径选项，那么，需要对当前节点进行复位操作（路径长度-1，取消路径节点的标记）。 参考实现 12345678910111213141516171819202122232425262728293031323334public class Solution &#123; public boolean hasPath(char[] matrix, int rows, int cols, char[] str) &#123; if(matrix==null||str==null||rows&lt;1||cols&lt;1)return false; boolean[] visit=new boolean[rows*cols]; for(int i=0;i&lt;rows*cols;i++) visit[i]=false; int pathlen=0; for(int row=0;row&lt;rows;row++)&#123; for(int col=0;col&lt;cols;col++)&#123; if(has(matrix,rows,cols,row,col,str,visit,pathlen)) return true; &#125; &#125; return false; &#125; public boolean has(char[] matrix, int rows, int cols,int row,int col, char[] str,boolean[]visit,int pathlen)&#123; if(pathlen==str.length)return true; boolean haspath=false;if(row&lt;rows&amp;&amp;col&lt;cols&amp;&amp;row&gt;=0&amp;&amp;col&gt;=0&amp;&amp;matrix[row*cols+col]==str[pathlen]&amp;&amp;!visit[row*cols+col])&#123; pathlen++; visit[row*cols+col]=true; haspath = has(matrix,rows,cols,row-1,col,str,visit,pathlen) ||has(matrix,rows,cols,row,col-1,str,visit,pathlen) ||has(matrix,rows,cols,row,col+1,str,visit,pathlen) ||has(matrix,rows,cols,row+1,col,str,visit,pathlen); if(!haspath)&#123; pathlen--; visit[row*cols+col]=false; &#125; &#125; return haspath; &#125;&#125; 题目13：机器人的运动范围 题目描述 地上有一个m行和n列的方格。一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格，但是不能进入行坐标和列坐标的数位之和大于k的格子。 例如，当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。但是，它不能进入方格（35,38），因为3+5+3+8 = 19。请问该机器人能够达到多少个格子？ 分析 回溯法求解，该题过程主要如下： 用count表示机器人能到达的格子的个数，机器人一开始从（0,0）开始移动，当它准备进入（i，j）时，首先检查是否能到达，如果能到达，count+1。再判断（i，j）周围相邻的格子（需要注意边界上的格子没有4个相邻格子）是否能够到达。使用一个数组来标记格子是否已达，避免重复累加。同时，定义函数返回某一格是否可达，这个函数主要是判断格子是否满足相应的约束条件。 参考实现 12345678910111213141516171819202122232425262728293031323334public class Solution &#123; public int movingCount(int threshold, int rows, int cols) &#123; if(threshold&lt;0||rows&lt;=0||cols&lt;=0)return 0; boolean[] visit = new boolean[rows*cols]; for(int i =0;i&lt;rows*cols;i++)&#123; visit[i]=false; &#125; return help(threshold,rows,cols,0,0,visit); &#125; public int help(int threshold,int rows,int cols,int row,int col,boolean[]visit)&#123; int count=0; if(check(threshold,rows,cols,row,col,visit))&#123; visit[row*cols+col]=true; count=1+help(threshold,rows,cols,row-1,col,visit) +help(threshold,rows,cols,row,col-1,visit) +help(threshold,rows,cols,row+1,col,visit) +help(threshold,rows,cols,row,col+1,visit); &#125; return count; &#125; public boolean check(int threshold,int rows,int cols,int row,int col,boolean[]visit)&#123; if(row&gt;=0&amp;&amp;row&lt;rows&amp;&amp;col&gt;=0&amp;&amp;col&lt;cols&amp;&amp;getNum(row)+getNum(col)&lt;=threshold&amp;&amp;!visit[row*cols+col])return true; return false; &#125; public int getNum(int num)&#123; int sum =0; while(num&gt;0)&#123; sum+=num%10; num/=10; &#125; return sum; &#125;&#125; 题目16：数值的整数次方 题目描述 给定一个double类型的浮点数base和int类型的整数exponent，求base的exponent次方。 分析 此题可以使用公式： {a^n}=\left\{\begin{matrix}{a^\frac{n}{2}}*{a^\frac{n}{2}},n为偶数\\ {a^\frac{n-1}{2}}*{a^\frac{n-1}{2}}*a,n为奇数 \end{matrix}\right.来求解a的n次幂，目的是可以减小乘法的次数，另外需要判断当幂指数不大于0和底数为0时的边界条件。 参考实现 12345678910111213141516171819public class Solution &#123; public double Power(double base, int exponent) &#123; double res=1.0; if((exponent&amp;1)==1)res=base; boolean flag=true; //标识位幂指数是否为负 if(exponent&lt;0)&#123;//转为正幂指数 if(base==0)return 0; flag=false; exponent*=-1; &#125; double tmp=base*base; while(exponent&gt;1)&#123;//求乘法 res*=tmp; tmp=res; exponent = exponent&gt;&gt;1; &#125; return flag?res:1/res; &#125;&#125; 题目21：调整数组数顺序使奇数位于偶数前面 题目描述 输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。 分析 该题和原书中的题有一点不一样，本题要求保证数组元素的稳定。书中最简单的方法是从头到尾扫描数组，碰到一个偶数，拿出来放到数组末尾，其他元素向前移动一位。没碰到一个偶数我们就要移动$O\left ( n \right )$该方法时间复杂度为$O\left ( n^{2} \right )$。书中改进的方法是设置两个指针分别指向数组两端，如果碰到奇数偶数对，那么交换。这种方法显然是不稳定的。 参考实现 1234567891011121314151617181920212223242526void ReorderOddEven_1(int *pData, unsigned int length)&#123; if(pData == nullptr || length == 0) return; int *pBegin = pData; int *pEnd = pData + length - 1; while(pBegin &lt; pEnd) &#123; // 向后移动pBegin，直到它指向偶数 while(pBegin &lt; pEnd &amp;&amp; (*pBegin &amp; 0x1) != 0) pBegin ++; // 向前移动pEnd，直到它指向奇数 while(pBegin &lt; pEnd &amp;&amp; (*pEnd &amp; 0x1) == 0) pEnd --; if(pBegin &lt; pEnd) &#123; int temp = *pBegin; *pBegin = *pEnd; *pEnd = temp; &#125; &#125;&#125; 上述书中的方法可以将while中对奇偶数的判断条件改成判定函数，则可以拓展代码的重用性。实现在给定的条件下，将数组划分成两部分。针对本题，考虑到稳定性，可以建一个队列，循环3次，分别将奇数、偶数打入队列，然后将队列输出修改原数组。时间复杂度是$3O\left( n\right)$，空间复杂度是$O\left(n\right)​$。 12345678910111213141516public class Solution &#123; public void reOrderArray(int [] array) &#123; if(array==null||array.length==0)return; int len = array.length; Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); for(int i=0;i&lt;len;i++)&#123; if((array[i]&amp;1)==1)queue.offer(array[i]); &#125; for(int i=0;i&lt;len;i++)&#123; if((array[i]&amp;1)==0)queue.offer(array[i]); &#125; for(int i=0;i&lt;len;i++)&#123; array[i]=queue.poll(); &#125; &#125;&#125; 题目22：链表中倒数第k个结点 题目描述 输入一个链表，输出该链表中倒数第k个结点。 分析 该题最简单的思路是遍历两次，一次求得链表长度，第二次找到倒数第k个点。优化的办法是，设置两个指针，第一个指针遍历到第k-1个节点，第二个指针再从头开始，两个指针同时扫描直至第一个指针到达链表末尾。此时第二个指针指向的就是倒数第K个节点。 这中间有几个边界条件需要特别注意： 输入链表为空 输入k为0 链表节点个数小于K 参考实现 12345678910111213141516171819202122232425262728293031/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode FindKthToTail(ListNode head,int k) &#123; if(head==null||k==0)return null; ListNode front=head; ListNode last; for(int i =1;i&lt;k;i++)&#123; if(front.next!=null)&#123; front=front.next; &#125; else&#123; return null; &#125; &#125; last=head; while(front.next!=null)&#123; last=last.next; front=front.next; &#125; return last; &#125;&#125; 题目23：链表中环的入口节点 题目描述 给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。 分析 本题主要考察的是指针的操作以及快慢指针的应用。题干中，我们首先需要判断链表是否有环，然后求得环的长度，最后借鉴题22的思路找到环的起始节点。时间复杂度为O(n) 参考实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode EntryNodeOfLoop(ListNode pHead) &#123; if(pHead==null)return null; ListNode p1=pHead; ListNode p2=pHead; while(p2!=null)&#123;//判断是否有环 p1=p1.next; if(p2.next!=null)&#123; p2=p2.next.next; &#125; else&#123; return null; &#125; if(p1==p2)break; &#125; int count=1; while(true)&#123;//求环的长度 p1=p1.next; if(p2!=p1)&#123; count++; &#125; else&#123; break; &#125; &#125; p1=pHead; //使用指针找到环的入口节点 while(count--&gt;0)&#123; pHead=pHead.next; &#125; while(pHead!=p1)&#123; p1=p1.next; pHead=pHead.next; &#125; return p1; &#125;&#125; 题目24：反转链表 题目描述 输入一个链表，反转链表后，输出新链表的表头。 分析 a-&gt;b-&gt;c-&gt;d…h-&gt;i-&gt;j-&gt;… a&lt;-b&lt;-c&lt;-d…h&lt;-i j-&gt;… 该问题关键在解决反转链表后的断裂怎么处理，我们用三个指针来处理。 参考实现 123456789101112131415161718192021222324/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode ReverseList(ListNode head) &#123; ListNode now = null; \\指向当前操作的节点 ListNode front = head; \\指向下一个操作的节点 ListNode res=null; \\指向反转链表的尾结点 while(front!=null)&#123; \\判断是否到达尾结点 now=front; \\获得本轮操作节点 front=front.next; \\front指向下一个节点，解决链表断裂 \\反转节点 now.next=res; res=now; &#125; return res; &#125;&#125; 题目25：合并两个排序的链表 题目描述 输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。 分析 链表合并的过程如下图所示： 每一次都是选择两个链表中较小值的节点作为合并链表的头结点，然后我们再将上一次合并链表的尾结点与本次的头结点链接起来，就可以得到合并的链表。具体实现，用递归是最简单的。时间复杂度为O(list1.length+list2.lenght) 参考实现 123456789101112131415161718192021222324/*public class ListNode &#123; int val; ListNode next = null; ListNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ListNode Merge(ListNode list1,ListNode list2) &#123; if(list1==null)return list2; else if(list2==null)return list1; ListNode res=null; if(list1.val&lt;list2.val)&#123; res=list1; res.next=Merge(list1.next,list2); &#125;else&#123; res=list2; res.next=Merge(list1,list2.next); &#125; return res; &#125;&#125; 题目26：树的子结构 题目描述 输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 分析 本题实际上考察的是树的遍历和树指针的操作，同时还有遍历过程中边界条件的处理。问题可以分成两步： 在A中找到与B根节点相同的节点；此步骤我们只需要遍历A树即可，我们任意选择一种树的遍历的方法即可，此处我们选择实现较为简单的递归遍历。遍历的边界条件是不能为空树； 判断A中该节点的子树和B是否有相同的结构；当我们能够遍历到B树的子节点的时候，代表两个子树有相同的结构。我们分别遍历左子树和右子树，当两个子树都有相同结构时，返回true，否则返回false。 参考实现 123456789101112131415161718192021222324252627282930/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public boolean HasSubtree(TreeNode root1,TreeNode root2) &#123; boolean res = false; if(root1!=null&amp;&amp;root2!=null)&#123; if(root1.val==root2.val)res=help(root1,root2); if(!res)res=HasSubtree(root1.left,root2); if(!res)res=HasSubtree(root1.right,root2); &#125; return res; &#125; public boolean help(TreeNode root1,TreeNode root2)&#123; if(root2==null)return true; if(root1==null)return false; if(root1.val!=root2.val)return false; return help(root1.left,root2.left)&amp;&amp;help(root1.right,root2.right); &#125;&#125; 题目27：二叉树的镜像 题目描述 操作给定的二叉树，将其变换为源二叉树的镜像。 输入描述： 二叉树的镜像定义：源二叉树 8 / \ 6 10 / \ / \ 5 7 9 11 镜像二叉树 8 / \ 10 6 / \ / \ 11 9 7 5 分析 本题实际上考察的是树的遍历，问题大致过程如下： 先前序遍历树的每个节点，当节点不是叶节点的时候，就交换两个子节点。要注意的是，虽然在遍历过程中对子节点进行了交换，但是递归的调用栈的顺序为前序遍历的顺序，不会改变。可以用递归直接实现，也可以借助队列循环实现。 参考实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public void Mirror1(TreeNode root) &#123; \\递归实现 if(root==null)return; if(root.left!=null||root.right!=null)&#123; TreeNode tmp=root.left; root.left=root.right; root.right=tmp; if(root.left!=null)Mirror(root.left); if(root.right!=null)Mirror(root.right); &#125; return; &#125; public void Mirror2(TreeNode root) &#123;\\循环实现 if(root==null)return; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; TreeNode now=queue.peek(); if(now.left!=null||now.right!=null)&#123; TreeNode tmp=now.left; now.left=now.right; now.right=tmp; queue.poll(); if(now.left!=null)queue.offer(now.left); if(now.right!=null)queue.offer(now.right); &#125;else&#123; queue.poll(); &#125; &#125; &#125;&#125; 题目28：对称的二叉树 题目描述 请实现一个函数，用来判断一颗二叉树是不是对称的。注意，如果一个二叉树同此二叉树的镜像是同样的，定义其为对称的。 分析 本题实际上考察的是树的遍历过程。树的前序、中序和后序遍历都是先访问左子树，然后再访问右子树。在本题中，我们不难发现，先访问右子树再访问左子树遍历得到的序列和原来先左后右遍历得到的序列应该相同。但是有一种特殊情况，就是树的所有节点的值相同，他们的输出序列永远相同。这个时候考虑树中空节点的情况，两种遍历方式中，遍历到某个位置的时候，两个位置要么相同，要么同时为空，否则就不对称。 参考实现 12345678910111213141516171819202122232425/*public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; boolean isSymmetrical(TreeNode pRoot) &#123; return isSymmetrical(pRoot,pRoot);\\让树分别从左子树和右子树两个方向遍历 &#125; boolean isSymmetrical(TreeNode p1,TreeNode p2)&#123; if(p1==null&amp;&amp;p2==null)return true; if(p1==null||p2==null)return false; if(p1.val!=p2.val)return false; return isSymmetrical(p1.left,p2.right)&amp;&amp;isSymmetrical(p1.right,p2.left); &#125;&#125; 题目30：包含min函数的栈 题目描述 定义栈的数据结构，请在该类型中实现一个能够得到栈中所含最小元素的min函数（时间复杂度应为O（1））。 分析 题干中我们需要定义一个栈，并且实现得到栈中最小元素的函数，并要求时间复杂度为O(1)。常规思路就是从栈顶通过迭代器搜索栈中最小的元素，但是这样做不符合时间复杂度的要求。因为题干没有限制空间复杂度，所以我们可以建一个辅助栈，使得栈顶元素始终是栈的最小元素。当然还有一种方法是建立最小堆，但是最小堆建立的时间复杂度是O(\log N)，也不符合题干要求。 参考实现 12345678910111213141516171819202122232425262728import java.util.Stack;public class Solution &#123; Stack&lt;Integer&gt; stack=new Stack&lt;&gt;(); Stack&lt;Integer&gt; min_stack=new Stack&lt;&gt;(); public void push(int node) &#123; stack.push(node); if(min_stack.isEmpty()||min_stack.peek()&gt;node)&#123; min_stack.push(node); &#125; &#125; public void pop() &#123; if(stack.isEmpty())return; else&#123; if(stack.peek()==min_stack.peek())min_stack.pop(); stack.pop(); &#125; &#125; public int top() &#123; return stack.peek(); &#125; public int min() &#123; return min_stack.peek(); &#125;&#125; 题目32：从上往下打印二叉树 题目描述 从上往下打印出二叉树的每个节点，同层节点从左至右打印。 分析 本题实际上考察的是树的层序遍历。借住队列，每次将父节点的左节点和右节点依次送入队尾，然后从队首取出元素的序列即为层序遍历。 参考实现 1234567891011121314151617181920212223242526272829/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/public class Solution &#123; public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; res=new ArrayList&lt;&gt;(); if(root==null)return res; Queue&lt;TreeNode&gt; queue =new LinkedList&lt;&gt;(); queue.offer(root); while(!queue.isEmpty())&#123; TreeNode now=queue.peek(); if(now.left!=null)queue.offer(now.left); if(now.right!=null)queue.offer(now.right); res.add(queue.poll().val); &#125; return res; &#125;&#125; 题目33：二叉搜索树的后序遍历序列 题目描述 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 分析 本题考查了二叉搜索树的结构，同时考查了数组的操作。 参考实现 123456789101112131415161718192021222324252627public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; if(sequence==null||sequence.length==0)return false; if(sequence.length&lt;3)return true; return help(sequence,0,sequence.length-1); &#125; public boolean help(int[] arr,int front,int last)&#123; if(front&gt;=last)return true; int target=arr[last]; int id1=front; if(arr[id1]&lt;target)&#123; while(id1&lt;last&amp;&amp;arr[id1]&lt;target)id1++; int id2=id1; while(id2&lt;last)&#123; if(arr[id2]&lt;target)return false; id2++; &#125; return help(arr,front,id1-1)&amp;&amp;help(arr,id1,last-1); &#125;else&#123; while(id1&lt;last)&#123; if(arr[id1]&lt;target)return false; id1++; &#125; return help(arr,front,last-1); &#125; &#125;&#125; 上述代码存在冗余，检测右子树重复了。我们可以优化一下： 12345678910111213141516171819public class Solution &#123; public boolean VerifySquenceOfBST(int [] sequence) &#123; if(sequence==null||sequence.length==0)return false; if(sequence.length&lt;3)return true; return help(sequence,0,sequence.length-1); &#125; public boolean help(int[] arr,int front,int last)&#123; if(front&gt;=last)return true; int i=front; while(i&lt;last)&#123; if(arr[i]&gt;arr[last])break; i++; &#125; for(int j=i;j&lt;last;j++)&#123; if(arr[j]&lt;arr[last])return false; &#125; return help(arr,front,i-1)&amp;&amp;help(arr,i,last-1); &#125;&#125; 题目34：二叉树中和为某一值的路径 题目描述 输入一颗二叉树的根节点和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。(注意: 在返回值的list中，数组长度大的数组靠前) 分析 题干中的条件是找到从根节点到叶节点的路径，路径始终是从根节点开始，所以我们只能是前序遍历二叉树。当我们访问某一个子节点的时候，如果不是叶节点，那么就继续向下遍历，并将节点添加到路径，target为target减去当前接节点的值。如果是叶节点的话，判断是否符合条件，如果符合那么将路径添加。否则返回父节点，在返回时要将当前节点从路径中删去。 参考实现 1234567891011121314151617181920public class Solution &#123; public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; FindPath(TreeNode root,int target)&#123; ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;(); if(root==null)return res; ArrayList&lt;Integer&gt; path = new ArrayList&lt;&gt;(); FindPath(root,target,res,path); return res; &#125; public void FindPath(TreeNode root,int target,ArrayList&lt;ArrayList&lt;Integer&gt;&gt; res,ArrayList&lt;Integer&gt; path)&#123; path.add(root.val); if(root.left==null&amp;&amp;root.right==null&amp;&amp;root.val==target)&#123; res.add(new ArrayList&lt;Integer&gt;(path)); &#125;else&#123; if(root.left!=null)FindPath(root.left,target-root.val,res,path); if(root.right!=null)FindPath(root.right,target-root.val,res,path); &#125; path.remove(path.size()-1); return; &#125;&#125; 题目35：复杂链表的复制 题目描述 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空） 分析 本题有两种思路，一种是在原来的链表每个节点后面都复制了一个同样的节点，再修改其指针，最后把偶数节点都抽出来，作为新的复杂链表。第二种实现比较简单，因为节点的结构相同，每一次复制的过程是一样的，所以我们可以用递归求下一个节点的复制。下图为第一种思路的示意图： 参考实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*public class RandomListNode &#123; int label; RandomListNode next = null; RandomListNode random = null; RandomListNode(int label) &#123; this.label = label; &#125;&#125;*/public class Solution &#123; //思路一： public RandomListNode Clone(RandomListNode pHead) &#123; if(pHead == null) &#123; return null; &#125; RandomListNode currentNode = pHead; //1、复制每个结点，如复制结点A得到A1，将结点A1插到结点A后面； while(currentNode != null)&#123; RandomListNode cloneNode = new RandomListNode(currentNode.label); RandomListNode nextNode = currentNode.next; currentNode.next = cloneNode; cloneNode.next = nextNode; currentNode = nextNode; &#125; currentNode = pHead; //2、重新遍历链表，复制老结点的随机指针给新结点，如A1.random = A.random.next; while(currentNode != null) &#123; currentNode.next.random = currentNode.random==null?null:currentNode.random.next; currentNode = currentNode.next.next; &#125; //3、拆分链表，将链表拆分为原链表和复制后的链表 currentNode = pHead; RandomListNode pCloneHead = pHead.next; while(currentNode != null) &#123; RandomListNode cloneNode = currentNode.next; currentNode.next = cloneNode.next; cloneNode.next = cloneNode.next==null?null:cloneNode.next.next; currentNode = currentNode.next; &#125; return pCloneHead; &#125; //思路二： public RandomListNode Clone(RandomListNode pHead) &#123; if(pHead==null)return null; RandomListNode res=new RandomListNode(pHead.label); if(pHead.random!=null)&#123; res.random=new RandomListNode(pHead.random.label); &#125; res.next=Clone(pHead.next); return res; &#125;&#125; 题目54：二叉搜索树的第K大节点 题目描述 给定一棵二叉搜索树，请找出其中的第k小的结点。例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。 分析 由二叉树的结构我们不难想到，二叉树的中序遍历序列是树节点的生序序列，如此我们只要得到中序遍历序列就可以找到第K大节点。主要考察的是树的遍历； 参考实现 123456789101112131415161718public class Solution &#123; TreeNode KthNode(TreeNode pRoot, int k) &#123; if(pRoot==null||k&lt;=0)return null; TreeNode res=null; ArrayList&lt;TreeNode&gt; tmp=new ArrayList&lt;&gt;(); help(pRoot,tmp,k,res); if(tmp.size()&lt;k)return null; return tmp.get(k-1); &#125; public void help(TreeNode root,ArrayList&lt;TreeNode&gt; tmp,int k,TreeNode res)&#123; if(root==null||tmp.size()&gt;=k)return; if(root.left!=null)help(root.left,tmp,k,res); tmp.add(root); if(root.right!=null)help(root.right,tmp,k,res); return; &#125;&#125; 题目55：二叉树的深度 题目描述 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。 分析 该题与题34有一点相似，都是从根节点到叶节点进行遍历。所以该题也只能是前序遍历这个树，我们采用递归的方式实现。题目要求树的深度，定义一个全局变量表示当前树的最大深度，定义一个局部变量表示当前树的深度，递归之后返回树的最大深度即可。下面给出两种解法： 参考实现 123456789101112131415161718192021222324252627282930313233343536373839/**public class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125;&#125;*/解法一：public class Solution &#123; int depth=0; public int TreeDepth(TreeNode root) &#123; int path=0; TreeDepth(root,path); return depth; &#125; public void TreeDepth(TreeNode root,int path)&#123; if(root==null)return; else&#123; if(++path&gt;depth)depth=path; if(root.left!=null)TreeDepth(root.left,path); if(root.right!=null)TreeDepth(root.right,path); &#125; &#125;&#125;解法二：public class Solution &#123; public int TreeDepth(TreeNode root) &#123; if(root==null)return 0; int left_depth=TreeDepth(root.left); int right_depth=TreeDepth(root.right); return left_depth&gt;right_depth?left_depth+1:right_depth+1; &#125;&#125; 延伸题：平衡二叉树的判定 题目描述 输入一棵二叉树，判断该二叉树是否是平衡二叉树。 平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。 分析 该题最直接的做法，遍历每个结点，借助一个获取树深度的递归函数，根据该结点的左右子树高度差判断是否平衡，然后递归地对左右子树进行判断。但是这样会重复遍历节点，我们可以简化一下，在判断当前子树不是平衡二叉树之后我们就直接返回，可以借助一个标志（-1）。 参考实现 12345678910111213public class Solution &#123; public boolean IsBalanced_Solution(TreeNode root) &#123; return getdepth(root)!=-1; &#125; public int getdepth(TreeNode root)&#123; if(root==null)return 0; int left=getdepth(root.left); if(left==-1)return -1; int right=getdepth(root.right); if(right==-1)return -1; return Math.abs(left-right)&gt;1?-1:1+Math.max(left,right); &#125;&#125; 未完待续…]]></content>
      <categories>
        <category>学习</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为实习生春招笔试（二）]]></title>
    <url>%2F2019%2F04%2F10%2F%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E7%94%9F%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[机试一共三道题：该题为其中第二道 题目描述： 给定一个字符串，字符串包含数字、大小写字母以及括号（包括大括号、中括号和小括号），括号可以嵌套。默认括号是匹配的，数字后面一定有括号。按照以下规则展开字符串： 数字表示括号里的字符串重复的次数，展开后的字符串不包括括号。 将字符串逆序展开 输入描述： 输入一个长度小于100的字符串 输出描述： 输出展开后的字符串 示例： 输入 1abc3(A) 输出 1AAAcba 思路：该题可以联想到数学式的混合运算的实现，借助栈来判断是否对当前数进行运算。本题中则是借助栈来判断是否对子结构进行一次字符串展开，子结构为: num（string）;算法思路如下： 从左至右遍历字符串，如果没有遇到右括号，则入栈。 当遇到右括号时，将其与左括号之间的字符出栈并存入临时字符串，并且重复n次 将展开后的字符串入栈，重复1，直至遍历结束。 将栈中的字符串弹出，即为展开后的逆序 1234567891011121314151617181920212223242526272829303132333435363738394041import java.util.*;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String input = sc.nextLine(); String res = ""; int i = 0; Stack&lt;String&gt; stack = new Stack&lt;&gt;(); if(input==null)return; while (i &lt; input.length()) &#123; if(input.charAt(i) == ']' || input.charAt(i) == ')' || input.charAt(i) == '&#125;')&#123; String t = ""; while (!stack.peek().equals("(") &amp;&amp;!stack.peek().equals("[") &amp;&amp;!stack.peek().equals("&#123;")) &#123; t = t + stack.pop(); &#125; stack.pop(); int s = Integer.valueOf(stack.pop()); String tmp =""; while (s--&gt;0)&#123; tmp +=t; &#125; stack.push(tmp); i++; &#125; else&#123; stack.push(String.valueOf(input.charAt(i++))); &#125; &#125; while(!stack.isEmpty())&#123; res = res + stack.pop(); &#125; System.out.print(res); &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[华为实习生春招笔试（一）]]></title>
    <url>%2F2019%2F04%2F10%2F%E5%8D%8E%E4%B8%BA%E5%AE%9E%E4%B9%A0%E7%94%9F%E6%98%A5%E6%8B%9B%E7%AC%94%E8%AF%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[机试一共三道题：该题为其中第一道 题目描述： 给定n个字符串，对字符串按序每8个字符分割出一个子串，对于原字符串或者分割剩余的字符串长度不足8的，在末尾补0。要求按照自然排序输出所有新的字符串。 输入描述： 输入一个整数n，在输入n个字符串，相互之间空格隔开。 输出描述： 输出规定的字符串 示例： 输入 12 abc 123456789 输出 112345678 90000000 abc00000 思路：主要是字符串的操作和字符串长度以及边界条件的问题。对于每个字符串按要求将分割的子串添加到数组末尾，并删除当前字符串。最后排序输出。 12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.*;public class Main1 &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); int n = sc.nextInt(); ArrayList&lt;String&gt; strings = new ArrayList&lt;&gt;(); while (n--&gt;0) &#123; strings.add(sc.next()); &#125; int size = strings.size(); for (int i = 0; i &lt;size; i++) &#123; //System.out.println(strings); String tmp = strings.get(0); int l = tmp.length(); int s = l/8; int ladd = 8-l%8; if(ladd==8)ladd=0; for (int j = 0; j &lt; s; j++) &#123; if(s&lt;1||ladd==0&amp;&amp;s==1)break; strings.add(tmp.substring(8 * j, 8 * (j+1))); &#125; String last = s&lt;1||ladd==0&amp;&amp;s==1?tmp:tmp.substring(s*8); while (ladd-- &gt; 0) &#123; last = last + "0"; &#125; strings.add(last); strings.remove(0); &#125; String[] str = strings.stream().toArray(String[]::new); Arrays.sort(str); for (int i = 0; i &lt; str.length; i++) &#123; if(i&lt;str.length-1) System.out.print(str[i]+" "); else System.out.print(str[i]); &#125; &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法题目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客相关问题]]></title>
    <url>%2F2019%2F04%2F10%2F%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Hexo常用命令123456789101112131415161718192021222324252627282930313233343536373839#简写hexo n "我的博客" == hexo new "我的博客" #新建文章hexo g == hexo generate#生成hexo s == hexo server #启动服务预览hexo d == hexo deploy#部署#服务器hexo server #Hexo 会监视文件变动并自动更新，您无须重启服务器。hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IPhexo clean #清除缓存 网页正常情况下可以忽略此条命令hexo g #生成静态网页hexo d #开始部署#监视文件变动hexo generate #使用 Hexo 生成静态文件快速而且简单hexo generate --watch #监视文件变动#草稿hexo publish [layout] &lt;title&gt;#模版hexo new "postName" #新建文章hexo new page "pageName" #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）hexo deploy #将.deploy目录部署到GitHub#例子hexo new [layout] &lt;title&gt;hexo new photo "My Gallery"hexo new "Hello World" --lang tw#推送到服务器上hexo n #写文章hexo g #生成hexo d #部署 #可与hexo g合并为 hexo d -g 简易发布流程主要是通过配置一个alias命令来实现 例如博客文件夹的路径为 C:\blog_backup，将其替换为你自己的路径 12git config --global alias.fuck '!cd C:\\blog_backup;hexo clean;hexo g -d'git fuck 在任意目录打开git bash，就能够实现上述命令集； 如果要取消alias的话，可通过以下方式 1git config --global --unset alias.fuck 个人设置了几个简易的命令： 123git blogview #更新博客内容并发布到本地服务器git blogupdate #更新博客内容并部署到网站git blognew #新建博客文章，初始化名字为“new title” 图床 先将图片文件上传至bmob，获取到图片链接后，直接在markdown中添加链接 图片命名格式：文章发布年月日-当天发表文章序号-文章内图片序号（说明） 序号以0起始 例如：20190222-0-1.png 文章分类结构文章主类分为：学习、工作、生活、爱好 标签可自行添加]]></content>
      <categories>
        <category>工作</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机网络的性能]]></title>
    <url>%2F2019%2F02%2F22%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E6%80%A7%E8%83%BD%2F</url>
    <content type="text"><![CDATA[主要介绍常用的七个性能指标: 速率比特(bit)是计算机中数据量的单位，也是信息论中使用的信息量的单位。英文单词bit来源于binary digit，意思是一个“二进制数字”。网络技术中的速率指的是连接在计算机网络上的主机在数字信道上传送数据的速率，它也称为数据率(data rate)或比特率(bit rate)。时间的基本单位是s(秒)，因此单位是bit/s(比特/秒，有时也写作bps，即bit per second)。（1Gbit/s = 10^3Mbit/s = 10^6Kbit/s = 10^9bit/s）。 注意：在通信领域和计算机领域，应特别注意数量单位“千”、“兆”、“吉”等的英文缩写所代表的数值。计算机中的数量单位用字节作为度量单位，“千字节”的“千”用大写K表示，它等于2^10，即1024，而不是1000。 带宽“带宽”有两种不同的意义： 带宽本来是指某个信号具有的频带宽度。信号的带宽是指该信号所包含的各种不同频率成份所占据的频率范围。这种意义的带宽的单位是赫。因此，表示通信线路允许通过的信号频带范围就称为线路的带宽(或通频带)。 在计算机网络中，带宽用来表示网络的通信线路传送数据的能力，因此网络带宽表示单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。这种意义的带宽的单位是比特/秒。 在“带宽”的两种表述中，前者为频域称谓，而后者为时域称谓，其本质是相同的。也就是说，一条通信链路的“带宽”越宽，其所能传输的“最高数据率”也越高。 注意：宽带运行商和电脑对宽带的速度单位是不一样的，电脑的单位是KBbs，而宽带运营商的单位是Kbbs，1B = 8b。例如你从宽带运营商那里办理了10M的宽带。 10Mbps = 10240Kbps / 8 = 1280KBps. 上行带宽和下行带宽，或者说上行速度和下行速度是什么意思? 我们访问互联网的过程中存在这两种行为：一是上传数据，二是下载数据。上行宽带(速度)指的是上传的速度，而下行宽带(速度)指的是下载数据是的数度。 上行宽带(速度)和下行宽带(速度)是不对称的，一般是下行速度大于上行的速度。我们平时所使用的宽带说多少M，都是指的下行宽带，因为我们上网主要是从互联网上下载数据，而上传的数据量要少很多。 吞吐量 吞吐量(throughput)表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量受网络带宽或网络的额定速率的限制。吞吐量更经常的用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。 时延 时延(delay 或 latency)是指数据（一个报文或分组，甚至比特）从网络（或链路）的一端传送到另一端所需的时间。时延是个很重要的性能指标。网络中的时延由以下几个不同的部分组成： 发送时延：指主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需要的时间。发生在机器内部的发生器中,与传输信道的长度没有任何关系。 发送时延计算公式：数据帧的长度(bits) / 发送速率(bits/s) 由此可见发送时延与发送的帧长成正比，与发送速率成反比。 传播时延：指电磁波在信道中传播一定距离需要花费的时间。 传播时延计算公式：信道长度(m) / 电磁波在信道上的传播速率(m/s) 电磁波在自由空间传播速率是光速：3.0×10^5km/s，铜线电缆中：2.3×10^5km/s，光纤中：2.0×10^5km/s。传播时延与信号的发送速率无关。信号传送的距离越远，传播时延就越大。 处理时延：主机或路由器在收到分组时要花费一定的时间进行处理，例如分析分组的首部、从分组中提取数据部分、进行差错检验或查找适当的路由等等。 排队时延：分组在经过网络传输时，要经过许多路由器。但分组在进入路由器后要先在输入队列中排队等待处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发。这就产生了排队时延。 总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延 注意：由于时延由以上四部分组成，所以不能笼统地认为：“数据的发送速率越高，传送得就越快”。同时需要特别注意一个错误观念：“在高速链路，比特应当跑得更快些”。这是不对的，因为对于高速网络链路，我们提高的仅仅是数据的发送速率，而不是比特在链路上的传播速率。提高数据的发送速率只是减少了数据的发送时延。而传播速率的单位是每秒传输多少公里，是指传输线路上比特的传播速率，通常是由线路决定而不变的。 时延带宽积 时延带宽积 = 传播时延 × 带宽 时延带宽积表示链路可容纳的比特数，因此，链路的时延带宽积又称为以比特为单位的链路长度。 往返时间RTT 往返时间RTT，表示从发送方发送数据开始，到发送方收到来自接收方的确认（接收方收到数据后便立即发送确认），总共经历的时间。往返时间一般就会包括分组在网络中的各种时延。 利用率利用率由信道利用率和网络利用率两种。信道利用率指出某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。网络的利用率则是全网络的信道利用率的加权平均值。信道利用率并非越高越好，这是因为，根据排队论的理论，当某信道的利用率增大时，该信道引起的时延也会迅速增加。信道或网络的利用率过高会产生非常大的时延。]]></content>
      <categories>
        <category>学习</category>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode148-排序链表]]></title>
    <url>%2F2018%2F11%2F05%2FLeetCode148-%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[题目来源：148. 排序链表在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序。示例1: 输入: 4-&gt;2-&gt;1-&gt;3 输出: 1-&gt;2-&gt;3-&gt;4 示例2: 输入: -1-&gt;5-&gt;3-&gt;4-&gt;0 输出: -1-&gt;0-&gt;3-&gt;4-&gt;5 思路：考查链表的排序，要求的时间复杂度可以联想到快速排序、堆排序、归并排序。由于是链表，我们选择二分归并排序比较容易实现。以下是Java的两种实现。 解法一：常规的插入排序，用时较多12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode sortList(ListNode head) &#123; ListNode root=new ListNode(0); root.next=head; ListNode p=head; while(p!=null&amp;&amp;p.next!=null)&#123; if(p.val&lt;=p.next.val)&#123;p=p.next;&#125; else&#123; ListNode tmp=root,q=p.next; while(tmp.next.val&lt;=q.val)&#123; tmp=tmp.next; &#125; p.next=q.next; q.next=tmp.next; tmp.next=q; &#125; &#125; return root.next; &#125;&#125; 解法二：二分归并排序,用时较少1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode sortList(ListNode head) &#123; if(head==null || head.next==null) return head; return mergeSort(head); &#125; private static ListNode mergeSort(ListNode head)&#123; if(head==null || head.next==null) return head; //分治 ListNode p1 = head; ListNode p2 = head; //遍历对链表二分 while(p2.next!=null &amp;&amp; p2.next.next!=null)&#123; p1 = p1.next; p2 = p2.next.next; &#125; ListNode left = head; //左子链 ListNode right = p1.next; //右子链 p1.next = null; //排序子链表 left = mergeSort(left); right = mergeSort(right); //合并 if(left==null) return right; if(right==null) return left; ListNode h = new ListNode(-1); ListNode p = h; //对左右两数进行比较 while(left!=null &amp;&amp; right!=null)&#123; if(left.val&lt;right.val)&#123; p.next = left; left = left.next; p = p.next; &#125;else&#123; p.next = right; right = right.next; p = p.next; &#125; &#125; if(left==null) p.next = right; else p.next = left; return h.next; //返回表头 &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>算法题目</tag>
        <tag>LeetCode-medium</tag>
      </tags>
  </entry>
</search>
